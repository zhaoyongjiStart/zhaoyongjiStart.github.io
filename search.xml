<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>operation-system</title>
      <link href="/2023/11/06/operation-system/"/>
      <url>/2023/11/06/operation-system/</url>
      
        <content type="html"><![CDATA[<p>操作系统</p> <span id="more"></span><h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><h3 id="程序是如何运行的？"><a href="#程序是如何运行的？" class="headerlink" title="程序是如何运行的？"></a>程序是如何运行的？</h3><p><img src="/2023/11/06/operation-system/image-20230802153031633.png" alt="image-20230802153031633"></p><h3 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h3><p>操作系统启动流程</p><img src="/2023/11/06/operation-system/image-20230802142902093.png" alt="image-20230802142902093" style="zoom: 33%;"><ol><li>CPU从一个特定主存地址开始，取指令，执行ROM的引导程序(先硬件自检).</li><li>将磁盘的第一块-主引导记录(MBR)读入内存，执行磁盘引导程序，扫描磁盘分区表。</li><li>根据磁盘分区表找到活动分区，读入活动分区的引导记录(PBR)，执行并找到“启动管理器”</li><li>启动管理器即为完整的操作系统初始化程序，执行。</li></ol><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-1-1-操作系统的概念、功能和目标"><a href="#1-1-1-操作系统的概念、功能和目标" class="headerlink" title="1.1_1 操作系统的概念、功能和目标"></a>1.1_1 操作系统的概念、功能和目标</h3><p>裸机:只有硬件</p><p>作为用户和计算机硬件之间的接口，控制与管理整个计算机系统的硬件与软件资源，并合理地组织调度计算机的工作和资源的分配。</p><ul><li><p>作为系统资源管理者提供的功能</p><ul><li><p>处理机管理</p></li><li><p>存储器管理</p></li><li><p>文件管理</p></li><li><p>设备管理</p></li></ul></li><li><p>提供的服务</p><ul><li><p>命令接口（联机命令接口(交互式)|脱机命令接口(批处理)）</p></li><li><p>程序接口</p><p>程序中进行系统调用(广义指令)来使用程序接口，普通用户只能通过程序代码间接使用程序接口。</p></li><li><p>GUI（图形用户界面）</p></li></ul></li></ul><ul><li>目标<ul><li>方便用户使用</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/107924376/213081351-e539c220-5ca4-4f21-8e77-06ec56f33d01.PNG"></p><h3 id="1-1-2-操作系统特征"><a href="#1-1-2-操作系统特征" class="headerlink" title="1.1_2 操作系统特征"></a>1.1_2 操作系统特征</h3><p>并发|并行</p><p>并发：多个事件同一时间间隔发生（宏观同时发生、微观交替进行）<br>并行：多个事件同时发生</p><p>共享</p><p>两种资源共享方式</p><ul><li>互斥共享方式：一个时间段内只允许一个进程访问该资源</li><li>同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问</li></ul><p>虚拟</p><p>概念：把一个物理上的实体变为若干个逻辑上的对应物</p><ul><li>空分复用技术</li><li>时分复用技术</li></ul><p>异步</p><p>概念：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。</p><h3 id="1-1-3-操作系统的发展与分类"><a href="#1-1-3-操作系统的发展与分类" class="headerlink" title="1.1_3 操作系统的发展与分类"></a>1.1_3 操作系统的发展与分类</h3><p>OS的发展与分类</p><ul><li><p>手工操作阶段</p><ul><li>纸带机（用户独占全机、人机速度矛盾）</li></ul></li><li><p>批处理阶段(引入脱机输入&#x2F;输出技术)</p><ul><li><p>单道批处理系统（外围机——磁带）</p><p>内存仅能有一道程序运行，cpu大多在空闲等待I&#x2F;O完成。</p></li><li><p>多道批处理系统（操作系统开始出现）</p><p>每次往内存中放入多道程序，多道程序并发执行。用户响应时间长，无人机交互。</p></li></ul></li><li><p>分时操作系统</p><ul><li>时间片为单位轮流处理作业</li><li>不能处理紧急任务</li></ul></li><li><p>实时操作系统</p><ul><li>优先处理紧急任务</li><li>硬实时系统：必须在严格的时间内完成处理</li><li>软实时系统：可以偶尔犯错</li></ul></li><li><p>网络操作系统</p></li><li><p>分布式操作系统</p></li><li><p>个人计算机操作系统</p></li></ul><h3 id="1-1-4-操作系统的运行机制"><a href="#1-1-4-操作系统的运行机制" class="headerlink" title="1.1_4 操作系统的运行机制"></a>1.1_4 操作系统的运行机制</h3><p>OS的运行机制和体系结构</p><ul><li><p>运行机制</p><ul><li><p>两种指令</p><ul><li>特权指令</li><li>非特权指令</li></ul></li><li><p>两种处理器状态</p><ul><li><p>核心态</p></li><li><p>用户态</p><p>(CPU有一状态寄存器(PSW)保存此时的处理器状态)</p></li></ul></li><li><p>两种程序</p><ul><li>内核程序(运行在核心态 ，实现操作系统)</li><li>应用程序</li></ul></li></ul></li></ul><h3 id="1-1-5操作系统体系结构"><a href="#1-1-5操作系统体系结构" class="headerlink" title="1.1_5操作系统体系结构"></a>1.1_5操作系统体系结构</h3><ul><li><p>操作系统功能</p><ol><li>时钟管理（实现计时功能）</li><li>中断处理</li><li>原语（程序运行具有原子性，不可中断）</li><li>对系统资源进行管理的功能</li></ol><ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li><li><p>操作系统的体系结构</p><ul><li><p>大内核（将操作系统的主要功能模块(上述全部)都作为系统内核，运行在核心态）</p></li><li><p>微内核（只把最基本的功能(1、2、3)保留在内核）</p></li></ul></li><li><p>内核设计优缺点</p><ul><li><p>大内核:高性能。内核程序庞大，结构混乱难维护。</p></li><li><p>微内核:内核功能少，结构清晰方便维护。性能低。</p></li></ul></li><li><p>其他内核设计</p><ul><li><p>分层结构内核设计</p><ul><li><p>内核分多层</p></li><li><p>最底层硬件，最高层为用户接口</p></li><li><p>每层可单向调用更低一层提供接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">便于调试和验证</span><br><span class="line">缺点</span><br><span class="line">难以定义边界，效率低，不可跨层使用，系统调用时间长。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>模块化内核设计</p><ul><li><p>内核划分为多个模块(内核&#x3D;主模块+客家在内核模块)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">模块间逻辑清晰易维护，调用其他模块时效率高</span><br><span class="line">缺点</span><br><span class="line">接口定义未必合理，模块间相互依赖难以调试。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>外核内核设计</p><ul><li><p>内核负责进程管理功能。</p></li><li><p>外核负责为用户进程分为未经抽象的硬件资源以及保证系统资源使用的安全。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">灵活使用资源，减少虚拟硬件映射层资源提升效率。</span><br><span class="line">缺点</span><br><span class="line">降低系统一致性</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="1-1-6-中断和异常"><a href="#1-1-6-中断和异常" class="headerlink" title="1.1_6 中断和异常"></a>1.1_6 中断和异常</h3><ul><li><p>中断机制的诞生</p><ul><li>操作系统介入，开展管理工作</li><li>“用户态—&gt;核心态”是通过中断实现的。并且中断是唯一途径</li></ul></li><li><p>中断的概念和作用</p></li><li><p>中断的分类</p><p>内中断（异常）</p><ul><li>陷阱（trap）</li><li>故障（fault）</li><li>中止（abort）</li></ul><p>外中断  （CPU外部）</p><ul><li>时钟中断</li><li>I&#x2F;O中断请求</li></ul></li><li><p>中断的判断<br>当cpu检测到中断，会根据中断类型查询“中断向量表”找到中断处理程序在内存中的地址。</p></li></ul><h3 id="1-1-7-系统调用"><a href="#1-1-7-系统调用" class="headerlink" title="1.1_7 系统调用"></a>1.1_7 系统调用</h3><p>概念：应用程序通过系统调用请求操作系统的服务。保证系统的稳定性和安全性。</p><ul><li><p>系统调用和库函数的区别：</p><ul><li><p>系统调用是操作系统向上层提供的接口</p></li><li><p>有的库函数是对系统调用的进一步封装</p></li><li><p>当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用</p></li></ul></li><li><p>系统调用过程：</p></li></ul><img src="/2023/11/06/operation-system/2023-07-31 18-30-45.png" alt="2023-07-31 18-30-45" style="zoom:33%;"><h3 id="1-1-8-虚拟机"><a href="#1-1-8-虚拟机" class="headerlink" title="1.1_8 虚拟机"></a>1.1_8 虚拟机</h3><p>使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(virtual machine),每个虚拟机都可运行一个操作系统。</p><p>采用虚拟机管理程序(virtual machine monitor)完成。</p><ul><li><p>第一类VMM，直接运行在硬件</p><p>当操作系统想运行特权指令，VMM会获取需求并进行相应模拟转换操作。</p></li></ul><img src="/2023/11/06/operation-system/image-20230802144410844.png" alt="image-20230802144410844" style="zoom:33%;"><ul><li><p>第二类，运行在宿主机上</p><img src="/2023/11/06/operation-system/image-20230802151923234.png" alt="image-20230802151923234" style="zoom:33%;"></li></ul><table><thead><tr><th>对比</th><th>第一类</th><th>第二类</th></tr></thead><tbody><tr><td>对物理资源的控制</td><td>直接控制和分配物理资源</td><td>依赖宿主机为其分配资源</td></tr><tr><td>资源分配方式</td><td>分配未经抽象的资源</td><td>拥有的是宿主机的一个文件，内存也是虚拟内存</td></tr><tr><td>性能</td><td>更好</td><td>差</td></tr><tr><td>可支持虚拟机数量</td><td>更多</td><td>少</td></tr><tr><td>虚拟机可迁移性</td><td>差</td><td>好</td></tr><tr><td>运行模式</td><td>运行于内核态</td><td>部分内核态，部分用户态。系统请求被VMM截获</td></tr></tbody></table><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1-1-进程的定义、组成、组织方式、特征"><a href="#2-1-1-进程的定义、组成、组织方式、特征" class="headerlink" title="2.1_1 进程的定义、组成、组织方式、特征"></a>2.1_1 进程的定义、组成、组织方式、特征</h3><p>与程序的不同之处</p><ul><li>程序是静态的，存在磁盘里的可执行文件。</li><li>进程是动态的，程序的一次执行过程。</li></ul><p>进程实体组成：</p><p>组成：PCB（进程存在唯一的标志），程序段(程序的代码)，数据段(运行过程中产生的数据)</p><p>组织方式：</p><ul><li>链接方式，指针指向不同的队列；</li><li>索引方式，索引表</li></ul><p>特征：</p><ul><li><p>动态性</p></li><li><p>并发性</p></li><li><p>独立性(资源分配的基本单位)</p></li><li><p>异步性</p></li><li><p>结构性</p></li></ul><h3 id="2-1-2-进程的状态与转换"><a href="#2-1-2-进程的状态与转换" class="headerlink" title="2.1_2 进程的状态与转换"></a>2.1_2 进程的状态与转换</h3><p>状态：</p><ul><li><p>运行状态：占有CPU，并在CPU上运行，单核只能一个进程（双核两个）（CPU√，其它资源√）</p></li><li><p>就绪状态：已经具备运行条件，但是没有空闲的CPU，暂时不能运行（CPUX，其它资源√）</p></li><li><p>阻塞状态：等在某个事件的发生，暂时不能运行（CPUX，其它资源X）</p></li><li><p>创建状态：正在创建PCB，程序段，数据段</p></li><li><p>终止状态：进程执行exit系统调用或中止(内中断),下处理机,回收PCB</p></li></ul><p>进程状态间的转换</p><p><img src="/2023/11/06/operation-system/operation-system%5Cimage-20230802154054020.png" alt="image-20230802154054020"></p><h3 id="2-1-3-进程控制"><a href="#2-1-3-进程控制" class="headerlink" title="2.1_3 进程控制"></a>2.1_3 进程控制</h3><p>实现各种进程状态转换。用“原语”实现。</p><p>原语做的事情：</p><ol><li>更新PCD中的信息</li><li>将PCD插入合适的队列</li><li>分配&#x2F;回收资源</li></ol><p>实现原语的原子性</p><ul><li>开中断指令(使用后CPU将不再例行检查中断信号，直到执行关中断指令)</li><li>关中断指令</li></ul><p><strong>进程控制相关的原语：</strong></p><p>1、进程的创建：</p><p>创建原语：</p><ol><li>申请空白PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入就绪队列</li></ol><p>引起进程创建的事件：用户登录、作业调度、提供服务、应用请求</p><p>2、进程的终止：</p><p>撤销原语</p><p>引起进程中止的事件：正常结束、异常结束、外界干预</p><p>3、进程的阻塞：</p><p>阻塞原语：运行态-&gt;阻塞态</p><p>引起进程阻塞的事件：需要等待系统分配某种资源、需要等待相互合作的其他进程完成工作</p><p>4、进程的唤醒：</p><p>唤醒原语：阻塞态-&gt;就绪态</p><p>引起进程唤醒的事件：等待的事件发生</p><p>5、进程的切换</p><p>切换原语</p><p>引起进程切换的事件：当前进程事件片到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止</p><h3 id="2-1-4-进程通信"><a href="#2-1-4-进程通信" class="headerlink" title="2.1_4 进程通信"></a>2.1_4 进程通信</h3><p>1、共享存储   （申请共享存储区作为共享空间进行通信，且互斥（P、V操作）</p><ul><li><p>基于数据结构的共享：固定分配（低级）</p></li><li><p>基于存储区的共享：划分存储区（高级），操作系统划分存储区，其他全由通信进行控制。</p></li></ul><p>2、消息传递(格式化消息为单位进行数据，进程通过“发送&#x2F;接受消息”两原语操作)</p><p>消息：消息头、消息体</p><ul><li><p>直接通信方式（发送进程指明接受进程PID，直接挂载消息至接受进程的PCB消息队列）</p></li><li><p>间接通信方式（间接利用信箱发送消息）</p></li></ul><p>3、管道通信（pipe）</p><p>只能半双工通信，类似队列，数据先进先出。管道数据一旦读出，便消失。</p><p>“管道数据一旦读出，便消失”引起多个进程同时读一管道异常，解决方法:</p><ul><li>一个管道允许多个写，一个读</li><li>多个写，多个读，读进程轮流读</li></ul><h3 id="2-1-5-线程概念和多线程模型"><a href="#2-1-5-线程概念和多线程模型" class="headerlink" title="2.1_5 线程概念和多线程模型"></a>2.1_5 线程概念和多线程模型</h3><p>提出原因:有的功能不能由一个程序，一个进程顺序处理完成。可能需要“同时”做许多事情。</p><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位，为了进一步提高了系统的并发度。</p><p>引入线程机制后的改变</p><ul><li><p>资源分配、调度：进程是资源分配的基本单位，线程是调度的基本单位。</p></li><li><p>并发性：各线程间也能并发，提升了并发度。</p></li><li><p>系统开销：同一进程中线程的切换不需要切换进程环境，减小了CPU切换环境的系统开销。</p></li></ul><p>线程有哪些重要的属性</p><ul><li>线程是处理机调度的基本单位</li><li>多核CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li></ul><p>2、线程的实现方式</p><p>用户级线程（ULT）：</p><p>早期操作系统不支持线程，线程由线程库实现。线程调度不需要更换CPU状态</p><p>优点</p><ul><li>线程调度不需要变态，开销小，效率高。</li></ul><p>缺点</p><ul><li>由于资源和运行机会是给到进程的。当用户级线程被阻塞，整个进程都会被阻塞，并发度不高，且一个进程的多个线程不能上多核处理机上并行处理。</li></ul><img src="/2023/11/06/operation-system/image-20230802160659158.png" alt="image-20230802160659158" style="zoom: 33%;"><p>内核级线程（KLT）：</p><p>由操作系统管理，从操作系统内核视角看能看到的线程,线程调度需要变态，各个内核级线程会有相应TCB。</p><p>优点</p><ul><li>一个线程被阻塞，另一个可以继续执行，并发能力强，可以上多核处理机上并行处理。</li></ul><p>缺点</p><ul><li>一个进程占用多个内核级线程，线程调度也由操作系统内核完成。开销大。</li></ul><img src="/2023/11/06/operation-system/image-20230802161245870.png" alt="image-20230802161245870" style="zoom:33%;"><p>3、多线程模型</p><p>多对一模型</p><p>n个ULT映射到1个KLT</p><p>优点：开销小，效率高</p><p>缺点：容易阻塞，并发度不高</p><p>一对一模型</p><p>n个ULT映射到n个KLT</p><p>优点：并发能力很强</p><p>缺点：占用成本高，开销大</p><p>多对多模型</p><p>n个ULT映射到m个KLT上（n&gt;&#x3D;m）</p><p>中和以上两种优缺点</p><h3 id="2-2-1-处理机调度的概念、层次"><a href="#2-2-1-处理机调度的概念、层次" class="headerlink" title="2.2_1 处理机调度的概念、层次"></a>2.2_1 处理机调度的概念、层次</h3><p>通常进程数量大于处理机数量，所以要按照一定的算法选择一个进程，并将处理机分配给它运行，以实现进程的并发执。</p><p>调度层次</p><ul><li><p>高级调度（作业调度）</p><p>从外存作业后备队列中挑选一个作业调入内存，为其创建进程，建立PCB，每个作业只会调度一次，调出一次。无-&gt;创建态-&gt;就绪态。</p></li><li><p>中级调度（内存调度）</p><p>内存不足时，将某进程放到外存（PCB不外放），提高内存利用率和系统吞吐量，进程状态为挂起状态，形成挂起队列(内存中存放)。这个步骤是内存不足的策略(交换技术)</p><p>决定哪个处于挂起态的进程重新调入内存。这个才是中级调度。挂起态-&gt;就绪态。</p></li><li><p>低级调度（进程调度&#x2F;处理机调度）</p><p>最基本，用算法为进程分配处理机资源,频率最高。就绪态-&gt;运行态。</p></li></ul><p>七状态模型</p><p>挂起态又可分为就绪挂起、阻塞挂起。</p><p><img src="https://user-images.githubusercontent.com/107924376/215522977-0a475c78-8425-41a5-a6a8-3931587af1f1.PNG"></p><h3 id="2-2-2-进程调度的时机、切换与过程调度方式"><a href="#2-2-2-进程调度的时机、切换与过程调度方式" class="headerlink" title="2.2_2 进程调度的时机、切换与过程调度方式"></a>2.2_2 进程调度的时机、切换与过程调度方式</h3><p><strong>时机</strong></p><p>什么时候需要进程调度？</p><ul><li><p>主动放弃（进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞）</p></li><li><p>被动放弃（分给进程的时间片用完、有更紧急的事需要处理、有更高优先级的进程进入就绪队列）</p></li></ul><p><strong>什么时候不能进行进程调度？</strong></p><ul><li><p>在处理中断的过程中</p></li><li><p>进程在操作系统内核程序临界区中</p><ul><li>临界资源：一个时段段内各进程互斥地访问临界资源</li><li>临界区：访问临界资源的那段代码</li><li>内核程序临界区:用来访问内核数据结构的代码，进程的就绪队列就是内核临界资源之一。</li></ul></li><li><p>在原子操作过程中（原语）</p></li></ul><p><strong>进程切换的定义</strong></p><p>“狭义的调度”与“进程切换”的区别</p><ul><li><p>狭义：选择一个进程</p></li><li><p>广义：狭义+进程调度</p></li></ul><p><strong>进程切换的过程需要做什么</strong>？</p><ul><li><p>对原来运行进程各种数据的保存</p></li><li><p>对新的进程各种数据的恢复</p></li></ul><p><strong>进程调度的方式</strong></p><ul><li>非剥夺调度方式（非抢占式）<ul><li>只允许进程主动放弃处理机</li></ul></li><li>剥夺调度方式（抢占式）<ul><li>进程被动放弃，可以优先处理紧急任务，适合分时操作系统、实时操作系统</li></ul></li></ul><p><strong>调度程序</strong></p><ul><li><p>功能</p><ul><li><p>实现调度算法</p></li><li><p>规定时间片大小</p></li></ul></li><li><p>方式</p><ul><li><p>抢占式</p></li><li><p>非抢占式</p></li></ul></li></ul><p><strong>闲逛程序</strong></p><p>没有其他就绪进程，就运行闲逛进程，其目的为在指令周期末尾例行检查中断，唤醒调度程序检查有无可运行进程。</p><p>特点</p><ul><li>优先级最低</li><li>能耗低</li><li>可以是0地址指令</li></ul><h3 id="2-2-3-调度算法的评价指标"><a href="#2-2-3-调度算法的评价指标" class="headerlink" title="2.2_3 调度算法的评价指标"></a>2.2_3 调度算法的评价指标</h3><p>1、CPU利用率</p><p>CPU利用率&#x3D;CPU忙碌的时间&#x2F;总时间</p><p>2、系统吞吐量</p><p>总共完成了多少道作业&#x2F;总共画了多少时间</p><p>3、周转时间</p><ul><li>周转时间（提交作业到完成作业花费的时间）、平均周转时间（各作业周转时间之和&#x2F;作业数）</li><li>带权周转时间（作业周转时间&#x2F;作业实际运行的时间）、平均带权周转时间（各作业带权周转时间&#x2F;作业数）</li></ul><p>4、等待时间</p><p>进程或作业等待处理机状态时间的和</p><ul><li><p>进程：建立后等待被服务的时间之和</p></li><li><p>作业：进程建立后的等待时间+作业在外存后备队列中等待的时间</p></li></ul><p>5、响应时间</p><p>从用户提交请求到首次产生响应所用的时间</p><h3 id="2-2-4-FCFS、SJF、HRRN调度算法-使用批处理系统"><a href="#2-2-4-FCFS、SJF、HRRN调度算法-使用批处理系统" class="headerlink" title="2.2_4 FCFS、SJF、HRRN调度算法(使用批处理系统)"></a>2.2_4 FCFS、SJF、HRRN调度算法(使用批处理系统)</h3><p>1、先来先服务（FCFS）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">非抢占式算法</span><br><span class="line">可用于进程/作业调度</span><br><span class="line">先到达先进行服务</span><br><span class="line">用于作业-谁先到外存后备队列；用于进程-谁先到内存就绪队列</span><br><span class="line">优点：</span><br><span class="line">公平、算法简单</span><br><span class="line">缺点：</span><br><span class="line">对长作业有利、对短作业不利、不会饥饿</span><br></pre></td></tr></table></figure><p>2、短作业优先（SJF，shortest job first）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">非抢占式（SJF）：选最短需要时间的作业先进入运行态</span><br><span class="line">抢占式（SRTN）：有新进程进入就绪队列或有进程完成了，考察队列中的最小需要时间的作业。</span><br><span class="line">可用于进程/作业调度。</span><br><span class="line">最短（服务时间最短）的作业/进程优先得到服务，时间相同，先到达的先被服务。</span><br><span class="line">在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少</span><br><span class="line">若无&quot;在所有进程都几乎同时到达时&quot;前提，抢占式的短作业/进程的平均时间最少</span><br><span class="line">优点</span><br><span class="line">“最短的”平均等待时间，平均周转时间。</span><br><span class="line">缺点</span><br><span class="line">对短作业有利，对长作业不利，可能产生饥饿现象。</span><br></pre></td></tr></table></figure><p>3、高响应比优先（HRRN）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">非抢占式算法</span><br><span class="line">可用于进程/作业调度</span><br><span class="line">要综合考虑作业/进程的等待时间和要求服务的时间</span><br><span class="line">在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</span><br><span class="line">响应比=（等待时间+要求服务时间）/要求服务时间</span><br><span class="line">进程主动放弃CPU时，需要该算法选取就绪队列的作业</span><br><span class="line">优点</span><br><span class="line">不会饥饿</span><br></pre></td></tr></table></figure><p>总结</p><p><strong>以上算法关心公平性和评价系统整体性能指标，不关心“响应时间”，亦不区分任务紧急程度且对用户来说交互性很差，适合早期批处理系统。</strong></p><h3 id="2-2-5-RR、优先级调度、多级反馈队列（适合交互式系统）"><a href="#2-2-5-RR、优先级调度、多级反馈队列（适合交互式系统）" class="headerlink" title="2.2_5  RR、优先级调度、多级反馈队列（适合交互式系统）"></a>2.2_5  RR、优先级调度、多级反馈队列（适合交互式系统）</h3><p>1、时间片轮转算法（RR）</p><ul><li><p>算法思想：公平轮流地位各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p></li><li><p>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队(若一个进程刚好因为时间片完下处理机，另一个新进程也刚好进入，默认先将新进程挂入就绪队列)</p></li><li><p>适用:只能用于进程调度</p></li><li><p>抢占式(作业无时间片)</p></li><li><p>优点：响应快，适用于分时操作系统</p></li><li><p>缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。时间片大小难以定义(如果时间片太大，则该算法退化为FCFS；时间片若太小，系统开销增大)</p></li><li><p>不会饥饿</p></li></ul><p>2、优先级调度算法</p><ul><li><p>算法思想：根据任务的紧急程度来决定处理顺序</p></li><li><p>算法规则：每个进程&#x2F;作业有各自的优先级，调度时选择优先级最高的作业&#x2F;进程</p></li><li><p>适用：作业&#x2F;进程&#x2F;IO调度</p></li><li><p>抢占式&#x2F;不可抢占均有</p></li><li><p>优先级调整</p><ul><li><p>静态优先级：创建进程时便固定。</p></li><li><p>动态优先级：创建进程时有一初始值，后续根据情况更改。</p><p>调整情况:进程在就绪队列时间太长可提升优先级、进程处于运行态太长可降低，进程频繁I&#x2F;O操作可提高</p></li></ul></li><li><p>通常：系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I&#x2F;O型进程(I&#x2F;O可与CPU并行)</p></li><li><p>优点:可以从追求公平、提升资源利用率等角度考虑改变优先级</p></li><li><p>缺点:可能会饥饿(源源不断地出现高优先级进程&#x2F;作业)</p></li></ul><p>3、多级反馈队列调度算法</p><ul><li>抢占式算法</li><li>算法实现：设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第一级队列，按照FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列末尾。只有第K级队列的进程为空时，才会为K+1级对头的进程分配时间片。若有K-1级队列有新进程加入，则k级队列正在运行的进程被抢占处理机并重新放回原队列队尾。K-1级队列新进程上处理机运行。</li></ul><p><img src="https://user-images.githubusercontent.com/107924376/217503736-9af47f43-351d-435c-9368-d926731a6302.PNG"></p><ul><li><p>优点：对各个进程相对公平（FCFS的优点），每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可以完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、IO密集型进程</p></li><li><p>缺点：会饥饿</p></li></ul><p>总结</p><p><strong>以上算法都适用于交互式系统。更注重响应时间、公平性、平衡性。</strong></p><h3 id="2-3-1-进程同步、进程互斥"><a href="#2-3-1-进程同步、进程互斥" class="headerlink" title="2.3_1 进程同步、进程互斥"></a>2.3_1 进程同步、进程互斥</h3><p>1、进程同步</p><p>指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。(例：先写才能读)</p><p>同步又称直接制约关系。</p><p>2、进程互斥</p><p>把一个时间段内只允许一个进程使用的资源称为临界资源。每个进程都需要<strong>互斥地</strong>访问临界资源。</p><p>对临界资源的互斥访问，可以在逻辑上分为四个部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    entry section;     <span class="comment">//进入区     对访问的资源检查或进行上锁</span></span><br><span class="line">    critical section;  <span class="comment">//临界区(段) 访问临界资源的那部分代码</span></span><br><span class="line">    exit section;      <span class="comment">//退出区     负责解锁</span></span><br><span class="line">    remainder section; <span class="comment">//剩余区     其它处理</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>实现进程互斥应遵循:</p><ul><li>空闲让进：资源空闲可以直接进去</li><li>忙则等待：资源繁忙不能进去</li><li>有限等待：不能让进程等待无限长时间</li><li>让权等待：不能使用资源，不要占着处理机。</li></ul><h3 id="2-3-2-进程互斥的软件实现方法"><a href="#2-3-2-进程互斥的软件实现方法" class="headerlink" title="2.3_2 进程互斥的软件实现方法"></a>2.3_2 进程互斥的软件实现方法</h3><p>1、单标志法</p><p>使用一个标志位来表达该进程是否有权限。</p><p>进程在访问完临界区后会把使用临界区的权限交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//p0进程</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//p1进程</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>存在的问题：访问权限在A，但A一直没有使用临界资源，此时临界资源为空闲但其他进程无法访问。违背：空闲让进原则</p><p>2、双标志先检查 </p><p>算法思想:设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿，每个进程占据数组中的一个值。当进程想访问临界资源时，先检测是否有其他进程是否意愿访问，如果没有则置自己的标志位为true，开始访问资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]=&#123;<span class="literal">false</span>,<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">//p1进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//p2进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>主要问题：由于进程是并发进行的，两个进程可能”同时”将自己的标志位置为true，违背忙则等待的原则</p><p>3、双标志后检查</p><p>算法思想:设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿,不过是先上锁后检查。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]=&#123;<span class="literal">false</span>,<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">//p1进程</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//p2进程</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>主要问题：由于进程是并发进行的，可能会两个“同时”上锁，然后检查其他人有意愿访问。违反空闲让进和有限等待原则，进而产生饥饿。</p><p>4、Peterson 算法</p><p>若双方都想使用临界资源，则主动让对方先使用。两个进程都放弃了资源，后放弃的那个进程是真的放弃了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]=&#123;<span class="literal">false</span>,<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> turn=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//p1进程</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">turn=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]&amp;&amp;turn==<span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//p2进程</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">turn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]&amp;&amp;turn==<span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>进程需要不断地轮询是否自己有访问的资格，未遵循让权等待的原则。</p><h3 id="2-3-3-进程互斥的硬件实现方法"><a href="#2-3-3-进程互斥的硬件实现方法" class="headerlink" title="2.3_3 进程互斥的硬件实现方法"></a>2.3_3 进程互斥的硬件实现方法</h3><p>1、中断屏蔽方法</p><ul><li><p>利用“开&#x2F;关中断指令”，使其他进程不能被调度，自然访问的资格就在正在执行的进程上。</p></li><li><p>缺点：不适用于多处理机，且只有操作系统内核进程才能使用(开&#x2F;关中断指令为特权指令)</p></li></ul><p>2、TestAndSet（TSK指令）</p><ul><li><p>TSL是用硬件实现的，上锁、检查一气呵成。适用于多处理机系统。</p></li><li><p>不满足让权等待(进程会循环执行TSK指令查看自己能否使用资源)</p></li></ul><p>C语言描述逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//true表示已经上锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> *lock)</span>&#123;</span><br><span class="line">    <span class="type">bool</span> old;</span><br><span class="line">    old=*lock;</span><br><span class="line">    *lock=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是使用TSL指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet (&amp;lock));<span class="comment">//上锁并检查</span></span><br><span class="line">临界区代码段</span><br><span class="line">lock=<span class="literal">false</span>; <span class="comment">//解锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、Swap指令</p><p>别称：Exchange指令、XCHG指令</p><p>用硬件实现”检查与上锁一气呵成”，适用于多处理机环境。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//true表示已经上锁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">bool</span> *a,<span class="type">bool</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">bool</span> temp;</span><br><span class="line">    temp=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是使用Swap指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="type">bool</span> old=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old=<span class="literal">true</span>)</span><br><span class="line">    Swap(&amp;lock,&amp;old);</span><br><span class="line">临界区代码段</span><br><span class="line">lock=<span class="literal">false</span>; <span class="comment">//解锁</span></span><br><span class="line"><span class="comment">//剩余代码段</span></span><br></pre></td></tr></table></figure><p>不满足让权等待</p><h3 id="2-3-4-信号量机制"><a href="#2-3-4-信号量机制" class="headerlink" title="2.3_4 信号量机制"></a>2.3_4 信号量机制</h3><p>信号量：</p><p>信号量是一种变量，表示系统中某种资源的数量</p><p>信号量机制:通过系统提供的一对原语(wait（S）原语和signal（S）原语，分别简称P（S）、V（S））实现进程互斥与同步</p><p>1、整形信号量</p><p>用一个整数表示系统资源的变量，用来表示系统中某种资源的数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S=<span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> S)</span>&#123; <span class="comment">//wait原语，相当于：进入区</span></span><br><span class="line">    <span class="keyword">while</span>(S&lt;=<span class="number">0</span>);  <span class="comment">//如果资源数不够，就一直循环等待</span></span><br><span class="line">    S=S<span class="number">-1</span>;        <span class="comment">//如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> S)</span>&#123;<span class="comment">//signal原语，相当于“退出区”</span></span><br><span class="line">    S=S+<span class="number">1</span>;         <span class="comment">//使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不满足让权等待。</p><p>2、记录型信号量</p><p>记录型数据结构表示的信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录型信号量的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//资源数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span><span class="comment">//等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"><span class="comment">//某进程需要使用资源时，通过wait原语申请</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(semaphore S)</span>&#123;<span class="comment">//P操作</span></span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;<span class="number">0</span>)&#123;<span class="comment">//判断资源是否足够</span></span><br><span class="line">        block (S.L);<span class="comment">//进程阻塞并将进程加入到等待队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程使用完资源后，通过signal原语释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span>&#123;<span class="comment">//V操作</span></span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.valie&lt;=<span class="number">0</span>)&#123;<span class="comment">//S.valie&lt;=0代表等待队列中还有等待使用临界资源的进程</span></span><br><span class="line">        wakeup(S.L);<span class="comment">//唤醒等待资源的进程，从阻塞态到就绪态(注意是阻塞态到就绪态)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非特别说明，否则默认S为记录型信号量</p><h3 id="2-3-5-用信号量机制实现进程互斥、同步、前驱关系"><a href="#2-3-5-用信号量机制实现进程互斥、同步、前驱关系" class="headerlink" title="2.3_5 用信号量机制实现进程互斥、同步、前驱关系"></a>2.3_5 用信号量机制实现进程互斥、同步、前驱关系</h3><p>1、实现进程互斥</p><p>设置互斥信号量mutex，初值为1</p><p>对不同的临界资源需要设置不同的互斥信号量</p><p>PV必须成对出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程</span><br><span class="line">P(mutex)//进入区</span><br><span class="line">临界区</span><br><span class="line">V(mutex)//退出区</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>2、实现进程同步</p><p>假设进程1先要执行了它的1、2代码才能执行进程2。则设mutex一开始为0，当进程2现执行，会被阻塞。只有当进程1执行V(mutex)进程2执行才不会被阻塞。</p><p><img src="/2023/11/06/operation-system/operation-system%5Cimage-20230803160343873.png" alt="image-20230803160343873"></p><p>3、实现进程的前驱关系</p><ul><li><p>要为每一对前驱关系各设置一个同步变量</p></li><li><p>在“前操作”之后对相应的同步变量执行V操作</p></li><li><p>在“后操作”之前对相应的同步变量执行P操作</p></li></ul><p><img src="https://user-images.githubusercontent.com/107924376/217713731-b387a1c7-cd88-4dd3-a605-a8f1a75261c9.PNG"></p><h3 id="2-3-6-生产者-消费者问题"><a href="#2-3-6-生产者-消费者问题" class="headerlink" title="2.3_6 生产者-消费者问题"></a>2.3_6 生产者-消费者问题</h3><p>系统中有一组消费者和生产者</p><ul><li><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</p></li><li><p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待</p></li><li><p>缓冲区是临界资源，各个进程互斥访问</p></li></ul><p>分析：需要有同步关系(先生产再消费)，互斥关系(缓存区为临界资源)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex=1//代表互斥信号量</span><br><span class="line">empty=n//同步信号量，代表空闲缓冲区数量</span><br><span class="line">full=0//同步信号量，代表已写入缓冲区数量</span><br></pre></td></tr></table></figure><img src="/2023/11/06/operation-system/image-20230803161640642.png" alt="image-20230803161640642" style="zoom:33%;"><p>注:<strong>实现互斥的P操作要放在实现同步的P操作之后，不然会发生死锁</strong></p><p>V操作不会导致进程发生阻塞的状态，所以可以交换</p><p>消费者使用数据操作不要放在临界区，不然并发度会降低</p><h3 id="2-3-7-多生产者-多消费者模型"><a href="#2-3-7-多生产者-多消费者模型" class="headerlink" title="2.3_7 多生产者-多消费者模型"></a>2.3_7 多生产者-多消费者模型</h3><p>在生产-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区</p><p>分析同步问题是，应该从“事件”的角度来考虑。</p><p>分析:互斥关系(盘子访问)，同步关系(父亲放儿子拿，母亲放女儿拿，盘中空才能放)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutex=1//盘中互斥访问</span><br><span class="line">apple=0</span><br><span class="line">orange=0</span><br><span class="line">plate=1</span><br><span class="line">注:盘子的互斥访问信号量可以省去，因为其他三个变量任一时刻都只可有一个为1.</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/107924376/217731751-b89c6ff8-ea6c-4cb6-bfd8-e571913e9820.PNG"></p><h3 id="2-3-8-吸烟者问题"><a href="#2-3-8-吸烟者问题" class="headerlink" title="2.3_8 吸烟者问题"></a>2.3_8 吸烟者问题</h3><p>解决“单生产者-多消费者”问题提供一个思路；</p><p>若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置</p><p>分析:同步关系(桌子上有组合1，吸者1取；桌子上有组合2，吸者2取；桌子上有组合3，吸者3取；吸烟者发出信号使供应者可以继续放材料的信号),互斥关系(取与拿不能一同,可不设置，因为四个同步关系信号量在同一时刻至多有一个1）。</p><p><img src="https://user-images.githubusercontent.com/107924376/217739518-1c7cf427-a1ac-457e-9293-5d055ab60a6c.PNG"></p><h3 id="2-3-9-读者-写者问题"><a href="#2-3-9-读者-写者问题" class="headerlink" title="2.3_9 读者-写者问题"></a>2.3_9 读者-写者问题</h3><ul><li><p>允许多个读者同时对文件执行读操作，读不会改变数据。</p></li><li><p>同一时刻只允许一个写者往文件中写信息</p></li><li><p>任一写者在完成写操作之前不允许其他读者或写者工作</p></li><li><p>写者执行写操作前，应让已有的读者和写者全部退出</p></li></ul><p>分析：</p><p>互斥关系:写与写互斥，写于读互斥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//用于保证对count变量的互斥访问</span></span><br><span class="line">semaphore w=<span class="number">1</span>; <span class="comment">//用于实现“写优先”</span></span><br><span class="line">    </span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P（w）;</span><br><span class="line">        P(rw); <span class="comment">//写之前“加锁”</span></span><br><span class="line">        写文件。。。</span><br><span class="line">        V（rw);<span class="comment">//写之后“解锁”</span></span><br><span class="line">    V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">    P(mutex);   <span class="comment">//各读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) </span><br><span class="line">            P(rw);  <span class="comment">//第一个读进程才上锁</span></span><br><span class="line">        count++;<span class="comment">//访问文件的读进程数+1</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        读文件...</span><br><span class="line">        P(mutex);<span class="comment">//各读进程互斥访问count</span></span><br><span class="line">        count--;<span class="comment">//访问文件的读进程数-1</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            V(rw);<span class="comment">//最后一个读进程负责“解锁”</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-10-哲学家进餐问题"><a href="#2-3-10-哲学家进餐问题" class="headerlink" title="2.3_10 哲学家进餐问题"></a>2.3_10 哲学家进餐问题</h3><p>五个人，必须拿左右的筷子才能吃饭</p><p>避免死锁发生</p><p>解决方案：<br>1、可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。</p><p>2、要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。</p><p>3、仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">//互斥地取筷子</span></span><br><span class="line">Pi()&#123; <span class="comment">//i号哲学家的进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        p(chopstick[i]);      <span class="comment">//拿右</span></span><br><span class="line">        p(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//拿左</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        吃饭...</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        思考...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-11-管程"><a href="#2-3-11-管程" class="headerlink" title="2.3_11 管程"></a>2.3_11 管程</h3><p>1、为什么要引入管程</p><ul><li>PV操作容易出错、困难</li></ul><p>2、管程的定义和基本特征</p><p>定义：</p><ul><li>局部于管程的共享数据结构说明</li><li>对该数据结构进程操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ul><p>基本特征：</p><ul><li>局部于管程数据结构只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据(可实现同步)</li><li>每次仅允许一个进程在管程内执行某个内部过程(实现互斥)</li></ul><p>心得：相当于面向对象的类，管程是数据放在private中，函数放在public中</p><p>拓展1：用管程解决生产者消费者问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">monitor producerconsumer</span><br><span class="line">    condition full,empty;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == N)</span><br><span class="line">            wait(full);</span><br><span class="line">        count++;</span><br><span class="line">        insert_item (item);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">            signal(empty);</span><br><span class="line">    &#125;</span><br><span class="line">    Item <span class="title function_">remove</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            wait(empty);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == N<span class="number">-1</span>)</span><br><span class="line">            signal(full);</span><br><span class="line">        <span class="keyword">return</span> remove_item();</span><br><span class="line">    &#125;</span><br><span class="line">    end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item = 生产一个产品;</span><br><span class="line">        producerconsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item = producerconsumer.remove();</span><br><span class="line">        消费产品 item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展2：Java中类似于管程的机制</p><p>java中用synchronized来描述一个函数,这个函数同一时间只能被一个线程调用</p><h3 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4_1 死锁的概念"></a>2.4_1 死锁的概念</h3><p>1、什么是死锁</p><p>并发环境下，各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>2、进程死锁、饥饿、死循环的区别</p><p>死锁：</p><ul><li><p>定义：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p></li><li><p>区别：至少两个或两个的进程同时发生死锁</p></li></ul><p>饥饿：</p><ul><li><p>定义：由于长期得不到想要的资源，某进程无法向前推进的现象。</p></li><li><p>区别：可能只有一个进程发生饥饿</p></li></ul><p>死循环：</p><ul><li><p>定义：某进程执行过程中一直跳不出某个循环的现象。</p></li><li><p>区别：死循环是程序员的问题</p></li></ul><p>3、死锁产生的必要条件</p><ul><li><p>互斥关系：多个进程争夺互斥资源才会导致死锁</p></li><li><p>不剥夺条件：进程获得的资源不能由其它进程强行抢夺，必须自己主动释放</p></li><li><p>请求和保持条件：某个进程有了一部分资源，还在请求资源</p></li><li><p>循环等待条件：存在资源的循环等待链</p></li></ul><p>PS : 死锁一定会循环等待，但循环等待不一定会死锁(循环等待是死锁的必要不充分条件),当同类资源大于1时，即使循环等待，也未必发生死锁。但当每类资源都只有 一个，则循环等待就是发生死锁的充要条件。</p><p>4、什么时候会发生死锁</p><ul><li>对系统资源的竞争</li><li>进程推进顺序非法</li><li>信号量的使用不当也会造成死锁</li></ul><p>5、死锁的处理策略</p><ul><li>预防死锁:破坏产生死锁的条件</li><li>避免死锁：使用银行家算法防止系统进入不安全状态</li><li>死锁的检测和解除：允许死锁发生，操作系统会检测死锁并处理</li></ul><h3 id="2-4-2-死锁的处理策略——预防死锁"><a href="#2-4-2-死锁的处理策略——预防死锁" class="headerlink" title="2.4_2 死锁的处理策略——预防死锁"></a>2.4_2 死锁的处理策略——预防死锁</h3><p>1、不允许死锁发生</p><ul><li>静态策略：预防死锁<ul><li>破坏互斥条件（适用范围不广）<br>把互斥的资源改造为共享资源(SPLooing技术)</li><li>破坏不剥夺条件（复杂，可能造成之前工作失效，系统开销增加，导致饥饿）<br>方案1：当进程请求新的资源得不到满足的时候，立即释放现有的资源<br>方案2：当进程需要的资源被其他进程占有时，由系统介入根据优先级强行帮助剥夺</li><li>破坏请求和保持条件（资源利用率极低，可能会导致某些进程饥饿）<br>采用静态分配方法，一次性全部申请，如果申请不到，不允许执行</li><li>破坏循环等待条件（不方便增加新的设备(重新编号)，实际使用与递增顺序不一致，会导致资源的浪费）<br>顺序资源分配法：对资源编号，进程按编号递增顺序请求资源</li></ul></li><li>动态检测：避免死锁</li></ul><p>2、允许死锁发生</p><ul><li>死锁的检测和解除</li></ul><h3 id="2-4-3-死锁的处理策略——避免死锁"><a href="#2-4-3-死锁的处理策略——避免死锁" class="headerlink" title="2.4_3 死锁的处理策略——避免死锁"></a>2.4_3 死锁的处理策略——避免死锁</h3><ul><li><p>什么是安全序列</p><p>系统按照某种序列分配资源使得每个进程都可以完成，这个序列就是<strong>安全序列</strong>，不会使系统发生死锁，找到这个序列，系统就是处于<strong>安全状态</strong>，反之处于不安全状态。</p></li><li><p>系统的安全状态与死锁有何联系<br>如果系统处于安全状态，就一定不会发生死锁。</p><p>如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定时在不安全状态）</p></li><li><p>如何避免系统进入不安全状态——银行家算法</p><p>系统维护一个表，包含每个进程对资源的最大需求、已经分配了得资源、最多还需要资源。</p></li></ul><p>​步骤：</p><p>​1. 当进程申请资源，检查此次申请是否超过了表中对应项的“最多还需要资源”，如果超过，引发中断。</p><p>​2. 检查此时系统剩余的可用资源是否还能满足该进程请求，若不满足，则进程继续等待。</p><p>​3. <strong>试探</strong>着分配，更改各表中记录</p><p>​4. 用安全性算法检查此次所分配是否会导致系统进入不安全状态，若依旧处于安全状态，则<strong>真正</strong>分配资源，否则恢复表中数据，让进程进入阻塞。</p><p>安全性算法:检查当前剩余可用资源是否满足某个进程最大需求</p><h3 id="2-4-4-死锁的处理策略——检测和解除"><a href="#2-4-4-死锁的处理策略——检测和解除" class="headerlink" title="2.4_4 死锁的处理策略——检测和解除"></a>2.4_4 死锁的处理策略——检测和解除</h3><p>死锁的检测</p><p>1、用某种数据结构(图)来保存资源的请求和分配信息</p><p>2、算法:依次消除不阻塞进程的边，直到没有边。称这个图可完全简化，此时一定没有发生死锁。**若最终不能消除所有的边，则一定发生了死锁(死锁定理)**，依旧连着边的进程节点对应的进程就是发生死锁的进程。</p><img src="/2023/11/06/operation-system/image-20230804154312935.png" alt="image-20230804154312935" style="zoom:33%;"><p>死锁的解除</p><p>1、资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。应预防进程饥饿。</p><p>2、撤销进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。付出代价大。</p><p>3、进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。需要记录进程历史消息，设置还原点。</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="3-1-1-内存的基础知识"><a href="#3-1-1-内存的基础知识" class="headerlink" title="3.1_1 内存的基础知识"></a>3.1_1 内存的基础知识</h3><p>1、什么是内存</p><ul><li>程序执行前需要放到内存中才能被CPU处理，目的是为了缓解CPU和磁盘之间的速度矛盾。</li></ul><p>内存编址</p><ul><li><p>产生原因:多道程序环境下，系统有多个进程并发执行，所有多个程序也会同时放入内存，为了区分每个程序所在位置，So，需要给内存划分存储单元并编址。</p></li><li><p>按字节编址</p><p>内存每个存储单元大小为1B(8字位)</p></li><li><p>按字编址(字指的是计算机的字长，16，32，64等字长的计算机)</p><p>设计算机为16位字长，每个存储单元为1字长，则每个字大小为16个二进制位。则存储单元换算后为2B(16字位)</p></li></ul><p>2、进程运行的前置工作</p><img src="/2023/11/06/operation-system/image-20230804164010031.png" alt="image-20230804164010031" style="zoom:33%;"><p>从写程序到程序运行</p><ul><li>编辑:程序员写代码</li><li>编译:编译程序将用户源代码编译成若干目标模块(高级语言-机器语言)</li><li>链接：将若干目标模块以及所需库函数链接在一起，形成一个完整装入模块(可执行程序)</li><li>装入:由装入程序将装入模块装入内存运行，以及逻辑地址到物理地址的转换。</li></ul><p>三种装入方式：</p><ul><li><p>绝对装入</p><p>在编译的时候就知道程序放在内存的哪个位置，<strong>编译程序将产生物理地址的目标代码</strong>。装入程序装入时对地址重定向(逻辑地址-物理地址)。</p><p>适用于单道程序环境，无操作系统。</p></li><li><p>静态重定位(重定位装入)</p><p><strong>装入程序装入时根据内存情况进行重定向。</strong></p><p>特点:一个作业装入内存时，必须分配整块内存空间且一次性分配。若无足够内存便无法装入，而且装入内存便无法移动，亦不能再申请内存空间。</p><p>适用于早期多道批处理系统。</p></li><li><p>动态重定位</p><p><strong>把地址转化推迟到程序真正要执行时才进行</strong>，使用重定位寄存器(保存转入模块放入内存中的起始位置)支持。</p><p>特点:允许程序在内存中移动。且可以将程序分配到不连续的内存空间中。无需一次性将全部模块都装入亦可运行(动态申请内存空间)。地址转换只需用重定位寄存器中数据加上逻辑地址的偏移量即可。</p></li></ul><p>三种链接方式：</p><ul><li>静态链接（在程序运行前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件）</li><li>装入时动态链接（将各目标模块装入内存时，边装入边链接的链接方式）</li><li>运行时动态链接（在程序执行中需要该模块时，才对它进行链接，其优点时便于修改和更新。）</li></ul><h3 id="3-1-2-内存管理需要实现的功能"><a href="#3-1-2-内存管理需要实现的功能" class="headerlink" title="3.1_2 内存管理需要实现的功能"></a>3.1_2 内存管理需要实现的功能</h3><ol><li><p>内存空间的分配与回收</p></li><li><p>内存空间的扩充(逻辑上扩充)，实现虚拟性。</p></li><li><p>地址重定向</p></li><li><p>内存空间保护(各进程互不干扰)</p></li></ol><p>内存空间保护</p><ul><li><p>设置上下限寄存器</p><p>存放进程的上下限地址，进程访问地址前，CPU通过这两个寄存器检查有无越界。</p></li><li><p>采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）</p><p>重定位寄存器放置进程起始物理地址，界地址存储器存放最大逻辑地址。</p></li></ul><p>内存空间扩充</p><ul><li><p>覆盖技术(一个进程中的操作)</p><p>将程序分为多个段(模块)，常用的常驻内存，不常用的在需要时调入。将内存分为一个“固定区”和若干“覆盖区”放置常驻内存的段和不常用的段。</p><p>缺点:必须由程序员声明覆盖结构，操作系统再完成覆盖。对用户不透明，增加编程负担。</p></li><li><p>交换技术(不同进程的操作)</p><p>内存紧张时，将某些进程换出外存，将某些具备运行条件的进程换入内存。具有对换功能的操作系统通常都会见磁盘空间划分为文件区和对换区。被换出的作业就存在对换区。可优先换出优先级低的、在内存驻留时间短的进程(PCB常驻内存，换出的是进程的程序段和数据段)。</p><p>文件区:追求存储空间利用率，采用离散分配方式</p><p>对换区:采用连续分配方式追求换入换出速度，采用连续分配方式。且一般对换区占据磁盘低地址部分空间。</p></li><li><p>虚拟技术</p></li></ul><p>内存空间分配与回收</p><ul><li><p>连续分配方式</p><ul><li><p>单一连续分配</p><p>内存被分配为系统区和用户区，系统区在低地址，内存中只有一个进程，该进程独占用户区。</p><p>优点:实现简单，无外部碎片。可采用覆盖技术，内存保护并不一定需要。</p><p>缺点:适用于单用户、单任务操作系统。有内部碎片，内存空间利用率低。</p></li><li><p>固定分区分配</p><p>将用户区分割为若干固定分区给各个进程，分割策略有分区大小相等和分区大小不相等，使用分区说明表来管理各个分区。</p><p>优点:实现简单，无外部碎片</p><p>缺点:用户程序太大，分区无法满足，采用覆盖技术又会降低性能。会产生内部碎片，内存利用率低。</p></li><li><p>动态分区分配(可变分区分配)</p><p>不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。采用空闲分区表或空闲分区链管理与记录内存使用情况</p><p>优点:没有内部碎片</p><p>缺点:有外部碎片</p></li></ul></li></ul><p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上</p><p>外部碎片：是指内存中的某些空闲分区由于太小而难以利用（如果有外部碎片，可以采用紧凑技术）</p><p>动态分区分配算法</p><p>1、首次适应算法（First Fit)</p><p>算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p>2、最佳适应算法(Best Fit)</p><p>算法思想：为了保证“大进程”到来时能有连续的大片区域，可以尽可能留下大片的空闲区，优先使用更小的空闲区。</p><p>空闲分区按容量递增次序链接，分配内存时顺序查找空闲分区链</p><p>缺点：外部碎片</p><p>3、最坏适应算法(Worst Fit)</p><p>算法思想：和最佳适应算法相反，按容量递减次序排列，每次尽可能用大的分区</p><p>缺点:“大进程”到来无内存空间可用</p><p>4、领近适应算法(Next Fit)</p><p>算法思想：地址递增排序，每次从上次查找结束的位置开始检索</p><p>缺点：高地址大空间容易被用完，“大进程”到来无内存空间可用</p><p>总结:</p><p>最佳适应算法、最坏适应算法需要经常对表&#x2F;链进行再次排序。开销大</p><p>领近适应算法、首次适应算法不需要要，算法开销小。</p><p>回收:</p><p>相邻有空闲分区便合并。</p><h3 id="3-1-6-基本分页存储管理的基本概念"><a href="#3-1-6-基本分页存储管理的基本概念" class="headerlink" title="3.1_6 基本分页存储管理的基本概念"></a>3.1_6 基本分页存储管理的基本概念</h3><p>非连续分配：为用户进程分配分散的内存空间</p><p>页框:</p><ul><li>将内存分为大小相等的小分区“页框”(页帧、内存块、物理块、物理页面)，每个页框都以一个编号–页框号，从零开始编号。</li></ul><p>页面:</p><ul><li>将用户的进程空间也分为大小相等的一个个区域—页面&#x2F;页，每个页&#x2F;页面都有一个编号–页号&#x2F;页面号。</li></ul><p>PS:一般来说，页框和页面同等大小</p><p>页表</p><ul><li>操作系统使用页表保存进程的页面号与页框号的映射</li></ul><img src="/2023/11/06/operation-system/image-20230806110516892.png" alt="image-20230806110516892" style="zoom:25%;"><p>页表项的大小</p><p>​假设内存为4GB(2^32^ bit),一个页框占4KB(2^12^bit),则内存中最多会有2^20^个页框，也需要20个二进制位来编址，按字节编址即3B(24bit)。</p><p>PS:计算机内部，地址使用二进制表示，如果页面大小为2的整数次幂大小则计算机可将逻辑地址拆为页号与页内偏移量。例:页面大小为2^12^bit,可使用32位来表示地址。前二十位表示页号，后12位表示页内偏移。</p><h3 id="3-1-7-基本地址变换机构-如何找到页表"><a href="#3-1-7-基本地址变换机构-如何找到页表" class="headerlink" title="3.1_7 基本地址变换机构(如何找到页表)"></a>3.1_7 基本地址变换机构(如何找到页表)</h3><p>页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M，进程未执行时，页表的起始地址和页表的长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。</p><p>地址转换流程</p><ul><li><p>根据给出的逻辑地址算出页号和偏移量</p></li><li><p>同页表计算器的值比较，查看有无越界。有则引发越界中断</p></li><li><p>根据页表寄存器的页表起始地址找到页表并访问对应的页表项地址</p><p>页表项地址&#x3D;页表起始地址+页号*页表项大小</p></li><li><p>计算物理地址</p><p>物理地址&#x3D;页框号*一个页框大小+偏移量</p></li><li><p>访问物理地址对应的内存单元</p></li></ul><p>PS:一共进行两次访问内存操作</p><h3 id="3-1-8-具有快表的地址变换机构-加快地址转换流程"><a href="#3-1-8-具有快表的地址变换机构-加快地址转换流程" class="headerlink" title="3.1_8 具有快表的地址变换机构(加快地址转换流程)"></a>3.1_8 具有快表的地址变换机构(加快地址转换流程)</h3><p>快表(联想寄存器TLB)，一种cache，用来存放最近访问的页表项的副本，可以加快地址变换的过程。内存中的页表也称为慢表。每次进程调度时快表都会清空。</p><img src="/2023/11/06/operation-system/image-20230806113829149.png" alt="image-20230806113829149" style="zoom:33%;"><p>地址转换流程</p><ul><li>根据逻辑地址得出页号与偏移量，查看快表中是否有对应页号项</li><li>若找到，则直接取出页框号再计算物理地址，之后访问目标内存地址。只需一次访问内存</li><li>若未找到，便访问内存中的页表找到对应表项，放入快表，再取出页框号计算物理地址。之后访问目标内存地址。若快表满了，可按照一定算法对页表项进行替换。两次访问内存。根据局部性原理，快表中有该表项的可能性为90%。</li></ul><p>局部性原理：</p><ul><li><p>时间局部性:由于程序中存在大量循环，程序执行了某条指令，这条指令可能在短时间内重复执行。同理，当数据被访问，该数据亦可能在短时间内重复访问。</p></li><li><p>空间局部性:由于许多数据在内存中连续存放，一旦程序访问了某个数据，在不久后这个数据附近数据也可能被访问。</p></li></ul><h3 id="3-1-9-两级页表"><a href="#3-1-9-两级页表" class="headerlink" title="3.1_9 两级页表"></a>3.1_9 两级页表</h3><p>1、单级页表存在什么问题？如何解决？</p><ul><li><p>所有页表项必须连续存放，页表过大时需要很大的连续空间</p></li><li><p>在一段时间内并非所有页面都用得到(局部性原理)，因此没必要让整个页表常驻内存。</p></li></ul><p>2、两级页表的原理、逻辑地址结构</p><p>将页表拆为多份，再拿一个页表–页目录表(存在PCB里)储存它们的位置。</p><p>注:使用多级页表机制时，各级页表大小不超过一个页面。</p><img src="/2023/11/06/operation-system/image-20230806131421779.png" alt="image-20230806131421779" style="zoom:33%;"><p>3、如何实现地址变换？</p><ul><li><p>按照地址结构将逻辑地址拆分成三部分</p></li><li><p>从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置</p></li><li><p>根据二级页号查表，找到最终想访问的内存块号</p></li><li><p>结合页内偏移量得到物理地址</p></li></ul><p>4、两级页表问题需要注意的细节</p><ul><li><p>若两级页表不够，可以分更多级。</p></li><li><p>多级页表的访问次数（假设没有快表结构）——N级页表访问一个逻辑地址需要N+1次访存。</p></li></ul><p>更近一步优化</p><p>可以在多级页表的基础上，只在需要访问页面时才把页面调入内存(虚拟存储技术)，在页表项中增加一个标志位用于表示是否已调入内存。</p><img src="/2023/11/06/operation-system/image-20230806143407973.png" alt="image-20230806143407973" style="zoom: 33%;"><h3 id="3-1-10-基本分段存储管理方式"><a href="#3-1-10-基本分段存储管理方式" class="headerlink" title="3.1_10 基本分段存储管理方式"></a>3.1_10 基本分段存储管理方式</h3><p>1、什么是分段？</p><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每段有段名，每段从0开始编址。</p><p>段名在编译后会被翻译为段号，从0开始。使用段表来管理每个进程的段。</p><img src="/2023/11/06/operation-system/image-20230806152025090.png" alt="image-20230806152025090" style="zoom: 25%;"><img src="/2023/11/06/operation-system/Users\yongji\AppData\Roaming\Typora\typora-user-images\image-20230806151646251.png" alt="image-20230806151646251" style="zoom:33%;"><p>段表结构</p><img src="/2023/11/06/operation-system/image-20230806152730087.png" alt="image-20230806152730087" style="zoom:25%;"><p>3、如何实现地址变换</p><p><strong>利用段表寄存器实现</strong>，进程未上处理机之前段表地址和段表长度存放在进程PCB里，当进程被调度时，内核程序会将这两个值放到段表寄存器当中。</p><ul><li><p>根据给出的逻辑地址得到段号，段内地址(偏移量)。</p></li><li><p>判断段号是否越界，是则引发越界中断。</p></li><li><p>根据段表寄存器找到段表，查询段表项</p><p>段表地址+段号*段表项长度</p></li><li><p>查看段内地址是否越界，是则引发越界中断。</p></li><li><p>计算物理地址</p><p>基址+段内地址</p></li></ul><p>PS:两次访问内存(查段表 ，访问目标内存地址)，可以引入快表。</p><p>4、分段、分页管理的对比</p><p>分页管理：</p><ul><li>信息的物理单位</li><li>目的是实现离散分配，提高内存利用率</li><li>分页是系统行为对用户不可见，页大小固定</li><li>地址空间是一维表(只需要保存页框号)</li></ul><p>分段管理：</p><ul><li>信息的逻辑单位</li><li>目的是更好满足用户需求</li><li>分段对用户可见，段大小不固定</li><li>地址空间是二维的(需要保存段内地址和基址)</li></ul><p>分段比分页更容易实现信息的共享和保护</p><ul><li>分段管理只需要在两个进程的段表中加入同一个段表项即可实现。</li><li>分页管理可能会导致需要共享与不能共享的数据被放入同一个页框，不易实现信息共享。</li></ul><h3 id="3-1-11-段页式存储管理方式"><a href="#3-1-11-段页式存储管理方式" class="headerlink" title="3.1_11 段页式存储管理方式"></a>3.1_11 段页式存储管理方式</h3><p>1、分页、分段管理方式最大的优缺点</p><p>分页：利用率高，少量页内碎片少，不方便按照逻辑模块进行信息共享和保护。</p><p>分段：方便信息共享和保护，如果段长过大，容易产生外部碎片。</p><p>段页式管理方式</p><p>分段+分页的结合——先分段再分页</p><img src="/2023/11/06/operation-system/image-20230806154946244.png" alt="image-20230806154946244" style="zoom: 33%;"><p>逻辑地址组成</p><p><img src="/2023/11/06/operation-system/image-20230806155129380.png" alt="image-20230806155129380"></p><p>段表、页表</p><img src="/2023/11/06/operation-system/image-20230806155947514.png" alt="image-20230806155947514" style="zoom: 33%;"><p>PS:一个进程有一个段表，多个页表。一个段表项对应着一个页表。</p><p>如何实现地址变换</p><ul><li><p>根据逻辑地址得到段号、页号、段内偏移量</p></li><li><p>判断段号是否越界，是则产生越界中断</p></li><li><p>根据段表寄存器找到段表，找到对应段表项</p><p>段表始址+段号*段表项长度</p></li><li><p>查询页号是否越界，是则引发越界中断</p></li><li><p>找到对应页表，取得页框号。</p></li><li><p>目标页框号加上页内偏移量得到目标物理地址。</p></li><li><p>访问目标内存单元</p></li></ul><p>PS:三次访问内存(段表、页表、目标内存地址)，可以引入快表。</p><h3 id="3-2-1-虚拟内存的基本概念"><a href="#3-2-1-虚拟内存的基本概念" class="headerlink" title="3.2_1 虚拟内存的基本概念"></a>3.2_1 虚拟内存的基本概念</h3><p>传统存储管理方式的特征、缺点</p><ul><li><p>一次性：作业必须全部装入内存后才能开始运行，并发性下降</p></li><li><p>驻留性：一旦作业被装入内存，就会一直驻留在内存。内存利用率不高</p></li></ul><p>解决办法:虚拟内存技术</p><ul><li>基于局部性原理，在程序装入内存时，可将程序很快用到的部分装入内存。暂时用不到的留在外存。</li><li>程序执行过程中，所访问的信息若不在内存中，由操作系统实现所需信息从外存到内存。</li><li>若内存不足，由操作系统实现将内存中暂时用不到的信息换出外存。</li></ul><p>虚拟内存的特征</p><ul><li><p>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调用内存</p></li><li><p>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入换出</p></li><li><p>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</p></li></ul><p>如何实现虚拟内存技术</p><ul><li><p>请求调页(调段)功能:</p><p>在程序执行过程中，当所访问的信息不再内存时，由操作系统负责将所需信息从外存调入内存</p></li><li><p>页面置换(段置换)功能:</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p></li></ul><p>PS:由此可见虚拟内存技术基于离散分配管理的！</p><h3 id="3-2-2-请求分页管理方式-请求调页与页面置换实现"><a href="#3-2-2-请求分页管理方式-请求调页与页面置换实现" class="headerlink" title="3.2_2 请求分页管理方式(请求调页与页面置换实现)"></a>3.2_2 请求分页管理方式(请求调页与页面置换实现)</h3><p>1、页表机制</p><img src="/2023/11/06/operation-system/image-20230807143246266.png" alt="image-20230807143246266" style="zoom:25%;"><ul><li>状态位:表示当前页面是否已调入内存。</li><li>访问字段：可以记录该页面被访问次数或上次被访问时间，用以衡量调出外存的参考 。</li><li>修改位:页面调入内存时是否被修改过，如果需要调出外存，可以判断需不需要覆盖外存数据。</li></ul><p>2、缺页中断机构</p><p>访问某逻辑地址，若页面不在内存中(查看状态位)，则产生缺页中断(内中断),进程进入阻塞态。</p><p>处理中断:</p><ul><li>内存中有空闲页框，则分配页框，装入，修改对应页表项。</li><li>内存中无空闲页框，利用页面置换算法选择页框替换，置换时还需判断被置换页面的修改位。</li></ul><p>3、地址变换机构</p><ul><li><p>根据逻辑地址得到页号及偏移量</p></li><li><p>根据页表寄存器判断是否引发越界中断</p></li><li><p>CPU检索快表</p><p>命中则修改页表对应表项再计算物理地址</p><p>不命中。根据页表寄存器访问页表，查看页是否在内存中，若在，修改页表对应表项；若不在，引发缺页中断。</p></li></ul><p>PS:缺页中断不一定导致页面置换，或许有空闲页框。</p><h3 id="3-2-3-页面置换算法"><a href="#3-2-3-页面置换算法" class="headerlink" title="3.2_3 页面置换算法"></a>3.2_3 页面置换算法</h3><p>1、最佳置换算法（OPT）</p><ul><li><p>每次选择淘汰的页面是以后永不使用或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p></li><li><p>缺点:无法实现，无法预知进程执行的页面序列。</p></li></ul><p>2、先进先出置换算法（FIFO）</p><ul><li><p>使用一队列记录页面调入的顺序，每次选择淘汰的页面是最早进入(队列队头)内存的页面。</p></li><li><p>缺点:Belady异常，当进程分配的页框增大时，缺页次数反而增加。</p></li></ul><p>3、最近最久未使用置换算法（LRU）</p><ul><li>每次淘汰最近最久未使用的页面,根据页表中的访问字段(存放页面从上次访问到现在所历时长)</li><li>缺点:算法需专门硬件支持(时钟)，性能好缺实现难，开销大。</li></ul><p>4、时钟置换算法（最近未用算法NRU，CLOCK算法）</p><ul><li><p>简单版</p><p>使用一循环链表记录已调入内存的页面，利用页表中的访问字段作为参考。若需淘汰，指针移动，遇到第一个访问字段为0的作为替换选项，当指针遇到1的时候将它置为0。</p><p>最多两次扫描</p><img src="/2023/11/06/operation-system/image-20230807145919691.png" alt="image-20230807145919691" style="zoom:25%;"></li><li><p>改进版</p><p>简单版未加入判断被置换页面是否被修改过的参考，可能会导致置换此类页面加重I&#x2F;O负担。</p><p>指针开始扫描:</p><p>第一轮扫描(找没访问没修改):找到未访问且未修改过的页面，沿途不更改任何标志位</p><p>第二轮扫描(找没访问但修改):查找第一个没访问过但修改过的页面，沿途被扫过的页面访问字段置为0</p><p>第三轮扫描(找访问没修改):查找第一个访问过但没修改过的页面，沿途不修改标志位。</p><p>第四轮扫描(找访问且修改):查找第一个没访问(第二次扫描访问位被置为0)且修改了的页面作为替换。</p></li></ul><img src="/2023/11/06/operation-system/image-20230807150620239.png" alt="image-20230807150620239" style="zoom:25%;"><h3 id="3-2-4-页面分配策略"><a href="#3-2-4-页面分配策略" class="headerlink" title="3.2_4 页面分配策略"></a>3.2_4 页面分配策略</h3><p>1、驻留集</p><p>指请求分页存储管理中给进程分配的页框的集合，采用了虚拟内存技术后驻留集的大小一般小于进程总大小。</p><ul><li>若驻留集太小:缺页频繁发生，系统处理中断开销大。</li><li>若驻留集太大:多道程序并发度下降，资源利用率下降。</li></ul><p>驻留集分配</p><ul><li>固定分配:进程被分配固定大小驻留集，整个运行过程中驻留集大小不变。</li><li>可变分配:先分配一定数目页框，再根据运行过程中需要动态增减。运行过程中驻留集大小可变。</li></ul><p>置换策略</p><ul><li>局部置换:缺页时只选择进程已有的页框进行置换。</li><li>全局置换:可置换其他进程所持有的页框。</li></ul><p>驻留集分配与置换策略的组合</p><ul><li>固定分配局部替换：驻留集大小不可改变，难以确定多大驻留集才合理。</li><li>可变分配全局替换：当系统空闲页框用完后，置换另一进程页框会导致另一进程页框减少，缺页率增加。</li><li>可变分配局部替换：当进程频繁缺页，会多分配页框。缺页率低时会减少驻留集大小。</li></ul><p>3、调入页面的时机</p><p>预调页策略：一次调用若干个相邻页面(局部性原理)，用于进程首次调入(运行前),由程序员指出哪些调用。</p><p>请求调页策略：进程运行时缺页调入，I&#x2F;O开销大。</p><p>4、从何处调页</p><ul><li>进程在运行前将相关数据复制到对换区。再将进程某些页面调入内存再执行。运行过程中的调入调出都在对换区进行。</li><li>当对换区空间不够时，则进程调用不会修改的页面都会从文件区中进行(修改过的页面都在对换区)。</li></ul><img src="/2023/11/06/operation-system/image-20230807154331969.png" alt="image-20230807154331969" style="zoom:25%;"><p>5、抖动（颠簸）现象</p><ul><li>页面频繁调入调出，即为抖动。主要原因为分配给进程的页框不够。</li></ul><p>6、工作集</p><ul><li>指在某段时间段内，进程实际访问页面的序列的集合。根据工作集里的页面大小，可作为驻留集大小的参考。</li></ul><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>实现文件访问及文件共享</p><p>传统文件访问</p><ul><li>open系统调用</li><li>seek系统调用-读写指针移动</li><li>read系统调用</li><li>write系统调用</li></ul><p>内存映射文件的访问方式</p><ul><li>open系统调用</li><li>mmap系统调用-将文件<strong>映射</strong>到进程的虚拟地址空间，当进程真正去读写文件时(读写指针)才真正将文件加入到内存(引发缺页中断)。于此，可以像访问内存一样访问文件数据，文件读写由操作系统完成。</li></ul><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="4-1-1-初识文件管理"><a href="#4-1-1-初识文件管理" class="headerlink" title="4.1_1 初识文件管理"></a>4.1_1 初识文件管理</h3><p>文件的属性</p><ul><li>名字、标志符(系统内部文件标识)、类型、位置(外存物理地址)、大小、创建时间、所有者、保护信息……</li></ul><h3 id="4-1-2-文件的逻辑结构"><a href="#4-1-2-文件的逻辑结构" class="headerlink" title="4.1_2 文件的逻辑结构"></a>4.1_2 文件的逻辑结构</h3><p>无结构文件(流式文件)</p><ul><li>文件由一系列二进制文件流组成</li></ul><p>有结构文件（记录式文件）</p><ul><li><p>文件每一行称为记录，每个“单元格”称为一个数据项，每条记录有一个数据项可作为关键字。根据各条记录长度是否相等可分为定长记录与变长记录。根据记录在逻辑上如何组织又可分为</p><p>顺序文件</p><p>​缺点:增&#x2F;删记录比较困难(串结构好一点)</p></li></ul><p><img src="/2023/11/06/operation-system/image-20230808145939017.png" alt="image-20230808145939017"></p><p>​索引文件</p><p>​建立一张索引表(定长记录的顺序文件)以加快文件的检索速度，每条记录为一个索引项。</p><p>​用于对信息处理即使性要求高的场合</p><p>​缺点:索引表可能会很大</p><p>​索引顺序文件</p><p>​也是建立索引表保存文件记录的信息，但一组记录对应一个索引项，分组内不需要按关键字排序。</p><p>​一组记录为一个顺序文件。可根据需求建立多级索引顺序文件。</p><h3 id="4-1-3-文件目录"><a href="#4-1-3-文件目录" class="headerlink" title="4.1_3 文件目录"></a>4.1_3 文件目录</h3><p>​每个文件夹(目录)就是一个文件目录表，表中一条记录对应着一个”文件控制块FCB“。</p><p>文件控制块（FCB）保存文件基本信息</p><ul><li>文件名、物理地址、逻辑地址、存取控制信息、使用信息。</li></ul><p>目录结构设计</p><ul><li><p>单级目录结构</p><p>整个系统只存在一张目录表，每个文件占一个目录表项。支持“按名存取”(给出名字可在表中查到唯一物理地址)，不允许文件重名。</p><p>不适用于多用户操作系统</p></li><li><p>两级目录结构</p></li></ul><p>​主文件目录（MFD）+用户文件目录（UFD）。不同UFD文件可以重名。可实现文件访问限制。</p><ul><li><p>多级目录结构（树形目录结构）</p><p>读取需要多次I&#x2F;O操作。可以设置当前目录(目录表已读入内存)来减少I&#x2F;O，使用相对路径来查找。不便于实现文件共享。</p></li><li><p>无环图目录结构</p><p>树型目录结构基础上，增加了指向同一文件或目录的有向边。使整个目录结构上看起来像是有向无环图结构。可以实现多用户共享。</p><p>需要为共享文件设置一共享计数器保存多少地方在共享该文件。用户删去文件时，只需删去对应FCB和共享计数器减1即可。当共享计数器为0时，代表这个文件应该被彻底删去。</p></li></ul><p>索引节点</p><p>在查找的过程中，只需要用到“文件名”这个属性。只有当文件名匹配时才需要获取其他信息。所以可以将文件其他信息放到某一位置。则目录表中只需有文件名和索引节点(保存这一位置的指针)，大大减少了目录表读入内存时使用的空间。I&#x2F;O读写也进一步加快。</p><h3 id="4-1-4-文件的物理结构（文件分配方式）"><a href="#4-1-4-文件的物理结构（文件分配方式）" class="headerlink" title="4.1_4 文件的物理结构（文件分配方式）"></a>4.1_4 文件的物理结构（文件分配方式）</h3><p>外存会被分为一个个“块&#x2F;磁盘块&#x2F;物理块”，每个块大小相等。数据读入以块为单位。大多数系统中磁盘块会与页框大小相等。文件在存储的时候也会被分为多个块放入到外存。</p><p>文件也会存在逻辑地址与物理地址</p><ul><li>逻辑地址:逻辑块号+块内地址</li><li>物理地址:物理块号+块内地址</li></ul><p>文件分配方式</p><ul><li><p>连续分配</p><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。</p><p>实现:只需要在目录表中记录文件的起始块号和长度即可。</p><p>优点:读取某个磁盘块时，需移动磁头。访问的块越远移动磁头所需时间越长，所以连续分配文件在顺序读写时速度最快。</p><p>缺点：对文件的拓展不方便，可能涉及文件整体迁移，开销大。存储空间利用率低，有很多磁盘碎片(可采用紧凑技术)。</p></li><li><p>链接分配</p><p>分配离散磁盘块，根据分配方式不同分为隐式与显式链接。</p><p>隐式分配：文件目录存放文件起始块号与结束块号，除起始块外其他块均保存下一块的指针。</p><p>​                   优点：方便文件拓展，不产生磁盘碎片。</p><p>​                   缺点：只支持顺序访问。</p><p>显示分配：使用文件分配表(FAT)保存每一块的下一块地址,一个磁盘只设一张FAT</p><p>​                   FAT常驻内存且每个表项连续存储。物理块号可以是隐含的。</p><p>​                   优点:查询目标块不需要磁盘I&#x2F;O，不产生磁盘碎片，支持随机访问</p><p>​                   缺点：FAT占内存</p><img src="/2023/11/06/operation-system/image-20230808162300464.png" alt="image-20230808162300464" style="zoom:25%;"></li><li><p>索引分配</p><p>离散分配，每个文件有一索引表记录了文件的各个逻辑块对应的物理块。(存放索引表的磁盘块也被称为索引块)，索引表存放在每个文件的FCB中。</p><p>地址变换:</p><ul><li>根据文件名字和逻辑块，操作系统查找相应FCB，查找索引块位置。</li><li>索引表读入内存</li></ul><p>优点:支持随机访问，文件拓展实现容易。</p><p>解决一个索引块装不下所有映射项问题</p><ul><li><p>链接方案：多个索引链接起来。低效。</p></li><li><p>多层索引方案：建立多层索引表。</p><ul><li><p>先将一级索引表调入内存，算出对应二级索引为位置。</p></li><li><p>二级索引表调入内存，查找对应磁盘块号</p></li><li><p>访问目标块号</p><p>PS:二级索引需要3次磁盘I&#x2F;O。</p></li></ul></li><li><p>混合索引：有的文件不需要多层索引，所以顶级索引表一部分为直接索引直接指向数据块，某些部分指向一级索引。</p><img src="/2023/11/06/operation-system/image-20230808174517099.png" alt="image-20230808174517099" style="zoom:25%;"></li></ul></li></ul><h3 id="4-1-5-文件存储空间管理"><a href="#4-1-5-文件存储空间管理" class="headerlink" title="4.1_5 文件存储空间管理"></a>4.1_5 文件存储空间管理</h3><p>1、存储空间的划分与初始化</p><ul><li><p>文件卷（逻辑卷）的概念</p><p>将整个磁盘从逻辑上分割，类似于windows系统上的C盘和D盘…每个盘又分为目录区与文件区。目录区存放文件目录信息，文件区存放文件数据。</p></li></ul><p>存储空间管理</p><ul><li><p>空闲表法：适用于连续分配方式。</p><p>分配</p><ul><li>首次适应</li><li>最佳适应</li><li>最坏适应</li></ul><p>回收</p><ul><li>上下有空闲区便合并</li></ul><img src="/2023/11/06/operation-system/image-20230808175244919.png" alt="image-20230808175244919" style="zoom:25%;"></li><li><p>空闲链表法（空闲盘块链、空闲盘区链）</p><ul><li><p>空闲盘块链:以空闲的盘块为单位组成链，操作系统保存链头与链尾。适合离散分配。</p><p>分配：从头开始，摘下所需盘块分配</p><p>回收：回收的依次加到链尾去</p></li><li><p>空闲盘区链:以一组连续的空闲盘块为单位组成链。适合离散与连续分配。</p><p>分配：可采用首次适应、最佳适应等算法进行分配</p><p>回收：上下有空闲盘区便合并，没有则挂到链尾</p></li></ul></li><li><p>位示图法</p><p>使用位示图来表达盘块的空闲情况。k而用于离散分配与连续分配。</p><p>表示一个盘块：（字号，位号）</p><p>计算盘块：字长*字号+位号</p><p>分配：顺序扫描位示图，空闲的分配</p><p>回收：计算盘块置标志位</p><img src="/2023/11/06/operation-system/image-20230808180706114.png" alt="image-20230808180706114" style="zoom:25%;"></li><li><p>成组链接法：文件卷的目录区中专门用一个磁盘块作为超级块，当系统启动时需要将超级内存块读入内存。并且保证内存与外存中的超级块数据一致。超级快中记录着系统某一组空闲盘块的信息和自身空闲盘块信息。</p></li></ul><h3 id="4-1-6-文件的基本操作"><a href="#4-1-6-文件的基本操作" class="headerlink" title="4.1_6 文件的基本操作"></a>4.1_6 文件的基本操作</h3><p>创建文件（create系统调用）</p><ol><li><p>在外存中找到文件所需的空间</p></li><li><p>创建该文件对应的目录项</p></li></ol><p>删除文件(delete)</p><ol><li>找到文件名对应的目录项</li><li>回收文件占用的磁盘块</li><li>删除文件对应的目录项</li></ol><p>读文件(read)</p><p>写文件(write)</p><p>打开文件(open)</p><ol><li><p>找到文件名对应的目录项</p></li><li><p>将目录项复制到内存中的“打开文件”中</p></li></ol><p>关闭文件(close)</p><h3 id="4-1-7-文件共享"><a href="#4-1-7-文件共享" class="headerlink" title="4.1_7 文件共享"></a>4.1_7 文件共享</h3><ul><li><p>基于索引结点的共享方式（硬链接）</p><p>索引节点直接存储目标文件的物理地址。</p><p>索引节点中有一链接计数变量count，表示链接到本索引节点的用户目录项数。</p><p>删文件时，只需将目录项去掉，再count–。操作系统还会检查count是否等于0，是则真正删去文件。</p></li><li><p>基于符号链的共享方式（软链接）</p><p>索引节点存放指向目标地址的link类型文件的物理地址。</p><p>索引节点指向的是一个link类型文件，该文件记录文件的存放路径。访问到该link类型文件时会根据该地址找到文件指向的索引节点。</p></li></ul><h3 id="4-1-8-文件保护"><a href="#4-1-8-文件保护" class="headerlink" title="4.1_8 文件保护"></a>4.1_8 文件保护</h3><ul><li><p>口令保护</p><p>为文件设置一“口令”，用户请求访问该文件需提供指令。正确口令一般存放在FCB或索引节点里。</p><p>优点：验证开销与保存口令开销小。</p><p>缺点：不够安全，入侵系统危机。</p></li><li><p>加密保护</p><p>使用某个密码对文件进行加密，访问文件时需提供正确密码才能正确解密。</p><p>优点：保密性强，不需要在系统中存储密码。</p><p>缺点：解密&#x2F;加密需一定时间。</p></li><li><p>访问控制</p><p>在每个文件的FCB或索引节点中增加一个访问控制列表（ACL），该列表记录了各个用户对该文件的访问权限。也可以不细分到各个用户层面，用户分为多个组：系统管理员、文件主、其他用户……以分为为单位授权。</p></li></ul><h3 id="4-1-9-文件系统的层次结构"><a href="#4-1-9-文件系统的层次结构" class="headerlink" title="4.1_9 文件系统的层次结构"></a>4.1_9 文件系统的层次结构</h3><img src="/2023/11/06/operation-system/image-20230809135544232.png" alt="image-20230809135544232" style="zoom: 50%;"><h3 id="4-2-1-虚拟文件系统-VFS"><a href="#4-2-1-虚拟文件系统-VFS" class="headerlink" title="4.2_1 虚拟文件系统(VFS)"></a>4.2_1 虚拟文件系统(VFS)</h3><p>不同外存可能使用不同的文件系统，如FAT、NTFS……它们在设计时可能使用不同规范。而VFS需要向上层用户进程提供统一标准的系统调用接口。以屏蔽底层文件系统的差异。</p><p>VFS要求下层文件系统必须实现某些规定函数功能。一个文件系统想要被操作系统使用，必须同时满足这些要求。</p><p>每打开一个文件，VFS便在内存中创建Vnode(文件信息),每个Vnode都有一个函数功能指针，指向该文件所属文件系统所提供的函数功能。</p><h3 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h3><ol><li>在VFS注册新挂载的文件系统。内存有一挂载表记录了每个文件系统的相关信息。</li><li>文件系统向VFS提供函数地址列表(Vnode函数功能指针指向位置)</li><li>将新文件系统挂载到某个父目录下</li></ol><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="5-1-1-I-O设备的概念和分类"><a href="#5-1-1-I-O设备的概念和分类" class="headerlink" title="5.1_1 I-O设备的概念和分类"></a>5.1_1 I-O设备的概念和分类</h3><p>什么是I-O设备</p><ul><li>unix将外部系统抽象为一种特殊的文件，用户可以使用文件与文件操作相同方式对外部文件进行操作。</li></ul><p>I&#x2F;O设备按使用特性分类</p><ul><li><p>人机交互类外部设备</p><p>鼠标、键盘</p><p>数据传输速度慢</p></li><li><p>存储设备</p><p>移动硬盘</p><p>数据传输速度快</p></li><li><p>网络通信设备</p><p>调制解调器</p><p>速度介于上面两种之间</p></li></ul><p>按传输速率分类</p><ul><li>低速设备、中速设备、高速设备</li></ul><p>按信息交换的单位分类</p><ul><li><p>块设备</p><p>磁盘</p><p>传输速率高、可寻址</p></li><li><p>字符设备</p><p>鼠标、键盘</p><p>传输速率慢、不可寻址。输入输出时采用中断驱动方式</p></li></ul><p>I&#x2F;O设备的组成</p><ul><li><p>机械设备</p><p>执行具体操作</p></li><li><p>电子部件(I&#x2F;O控制器、设备控制器)</p><p>插入主板扩充槽的印刷电路板，作为CPU和机械部件的中介，实现CPU对设备的控制。</p></li></ul><h3 id="5-1-2-I-O控制器"><a href="#5-1-2-I-O控制器" class="headerlink" title="5.1_2 I-O控制器"></a>5.1_2 I-O控制器</h3><p>I&#x2F;O控制器功能</p><ul><li><p>接受和识别CPU发出的命令</p><p>内置相应控制寄存器来存放命令和参数</p></li><li><p>向CPU报告设备的状态</p><p>内置状态寄存器记录当前状态</p></li><li><p>数据交换</p><p>内置数据寄存器来存放CPU或设备的数据</p></li><li><p>地址识别</p><p>各个寄存器有一地址</p></li></ul><p>I&#x2F;O控制器组成</p><p><img src="https://user-images.githubusercontent.com/107924376/222328366-c649e96f-b86c-47cc-bece-67c544b18f78.PNG"></p><p>寄存器编址方式</p><ul><li><p>内存映像I&#x2F;O</p><p>占用内存地址的一部分</p></li><li><p>寄存器独立编址</p><p>采用I&#x2F;O专门地址</p></li></ul><h3 id="5-1-3-I-O控制方式"><a href="#5-1-3-I-O控制方式" class="headerlink" title="5.1_3 I-O控制方式"></a>5.1_3 I-O控制方式</h3><ul><li><p>程序直接控制方式</p><ul><li><p>完成一次读操作流程</p><ol><li><p>CPU向控制器发出指令，相应设备被控制器启动。设备对应状态寄存器设置为1(忙碌)</p></li><li><p>CPU<strong>轮询</strong>检查设备对应状态寄存器状态</p></li><li><p>当设备准备好数据并发地发送给控制器，附带自身状态。</p></li><li><p>控制器将设备的数据放到数据寄存器当中，并置状态寄存器为0(就绪)</p></li><li><p>CPU发现设备就绪，便从数据寄存器中读出数据进入CPU寄存器中，再放入内存。</p></li><li><p>若还需要继续读，则CPU再次发出指令</p><p>PS:控制器指的是I&#x2F;O逻辑</p></li></ol></li><li><p>CPU干预频繁</p><p>频繁。I&#x2F;O操作之前、完成都需要CPU介入。且等待时还不断轮询</p></li><li><p>数据传送单位</p><p>每次读写一个字</p></li><li><p>数据流向</p><p>I&#x2F;O设备-CPU寄存器-内存</p></li><li><p>优点</p><p>实现简单</p></li><li><p>缺点</p><p>CPU与I&#x2F;O设备只能串行工作，CPU一直轮询查看。长期处于忙等，CPU利用率低。</p></li></ul></li><li><p>中断驱动方式</p><ul><li><p>实现</p><p>在程序控制直接方式基础上引入中断机制。</p><p>当CPU发出读写命令后，先将等待I&#x2F;O的进程阻塞。执行其他进程。直到I&#x2F;O完成，控制器向CPU发送中断信号，CPU便可以执行中断了。</p></li><li><p>CPU干预频率</p><p>I&#x2F;O操作开始之前与完成之后需CPU干预</p></li><li><p>数据传送单位</p><p>字</p></li><li><p>数据流向</p><p>I&#x2F;O设备-CPU寄存器-内存</p></li><li><p>优点</p><p>CPU和I&#x2F;O设备可并行执行</p></li><li><p>缺点</p><p>频繁中断处理消耗CPU时间</p></li></ul></li><li><p>DMA方式(直接存储器存取direct memory access)</p><ul><li><p>使用DMA控制器(一种I&#x2F;O控制器)实现</p><ul><li><p>I&#x2F;O控制逻辑</p></li><li><p>主机-控制器接口</p><p>DR(数据寄存器)</p><p>MAR(内存地址寄存器):表示要输入输出的数据处于内存的那个位置</p><p>DC(数据计数器)：剩余要读写字节数</p><p>CR(命令&#x2F;状态寄存器)：存放cpu发来的I&#x2F;O命令及设备的状态信息</p></li><li><p>块设备-控制器接口</p></li></ul></li><li><p>完成读过程</p><p>CPU向I&#x2F;O控制器发出读命令之后阻塞当前进程，并且将接下来的工作交给DMA</p><p>I&#x2F;O完成后由DMA控制器完成数据的接受与传送</p></li><li><p>CPU干预频率</p><p>传送一个块和多个块的开始和结束时才需要CPU干预</p></li><li><p>数据读写单位</p><p>一个块或多个连续的块</p></li><li><p>数据流向</p><p>设备-内存</p></li><li><p>优点</p><p>CPU接入频率低，不需CPU作为中转站。并行度上升</p></li><li><p>缺点</p><p>CPU每一条I&#x2F;O指令只能读写一个或多个连续的块。</p></li></ul></li><li><p>通道控制方式</p><ul><li><p>实现</p><p>通道是一种硬件，可识别一系列通道指令。通道与CPU共享内存。</p></li><li><p>读流程</p><ol><li>CPU向通道发送I&#x2F;O指令(包括通道程序在内存中的地址、操作哪个I&#x2F;O设备)，之后进程调度。</li><li>通道执行内存中的通道程序(读多少数据及数据地址)</li><li>通道执行完成任务后向CPU发出中断信号</li></ol></li><li><p>CPU干预频率</p><p>完成一组数据块读写的开始与结束才需CPU干预</p></li><li><p>传送单位</p><p>一组数据块</p></li><li><p>数据流向</p><p>设备-内存</p></li><li><p>优点</p><p>CPU、通道、I&#x2F;O设备可并行工作。资源利用率高。</p></li><li><p>缺点</p><p>实现复杂、需要专门硬件支持。</p></li></ul></li></ul><h3 id="5-1-4-I-O软件层次结构"><a href="#5-1-4-I-O软件层次结构" class="headerlink" title="5.1_4 I-O软件层次结构"></a>5.1_4 I-O软件层次结构</h3><img src="/2023/11/06/operation-system/image-20230809154613327.png" alt="image-20230809154613327" style="zoom:25%;"><ul><li><p>用户层软件</p><p>实现与用户交互的接口，向上提供方便易用的库函数</p><p>将用户请求翻译成格式化的I&#x2F;O请求，通过系统调用请求内核服务。</p><img src="/2023/11/06/operation-system/image-20230809154730411.png" alt="image-20230809154730411" style="zoom: 33%;"></li><li><p>设备独立性软件（设备无关性软件）</p><p>与硬件特性无关的功能实现:</p><ul><li><p>设备的保护</p></li><li><p>差错处理</p></li><li><p>设备的分配与回收</p></li><li><p>数据缓冲区管理</p></li><li><p>建立逻辑设备名到物理设备名的映射关系</p></li><li><p>根据设备类型选择调用相应的驱动程序</p></li></ul></li><li><p>设备驱动程序</p><p>不同厂商生产的硬件内部电子部件可能完全不同，硬件特性也可能不同。So，需要不同设备驱动程序，驱动程序一般以一个独立进程存在。</p></li><li><p>中断处理程序</p></li><li><p>硬件</p></li></ul><h3 id="输入-输出应用程序接口"><a href="#输入-输出应用程序接口" class="headerlink" title="输入&#x2F;输出应用程序接口"></a>输入&#x2F;输出应用程序接口</h3><p>无法用统一的系统调用操作所有类型的I&#x2F;O</p><ul><li>字符设备接口：字符为单位进行数据交换</li><li>块设备接口：以多个字符为单位进行数据交换</li><li>网络设备(Socket)接口</li></ul><h3 id="5-1-6-假脱机技术-SPOOLing"><a href="#5-1-6-假脱机技术-SPOOLing" class="headerlink" title="5.1_6 假脱机技术(SPOOLing)"></a>5.1_6 假脱机技术(SPOOLing)</h3><p>批处理系统节点利用脱机输入&#x2F;输出技术(磁带实现)来解决手工操作阶段问题脱离主机的控制进行输入&#x2F;输出控制</p><p>假脱机技术:软件模拟脱机技术</p><p><img src="/2023/11/06/operation-system/image-20230809160627730.png" alt="image-20230809160627730"></p><img src="/2023/11/06/operation-system/image-20230809161354031.png" alt="image-20230809161354031" style="zoom:33%;"><p>共享打印机(SPOOLing技术实现共享)的原理分析</p><p>多个用户申请打印机，系统全接受。</p><p>假脱机管理进程启动:</p><ul><li>​在磁盘输出井中为进程申请一个空闲缓冲区，并将要打印数据放入其中</li><li>​为每个用户进程申请空白打印请求表，并将用户打印请求填入表中，再将该表挂到假脱机文件队列上。</li></ul><p>当打印机空闲，输出进程会从文件队列上取出一张打印请求表。并将数据从输出井传送到输出缓存区，再输出到打印机中进行打印。</p><h3 id="5-1-7-设备的分配与回收"><a href="#5-1-7-设备的分配与回收" class="headerlink" title="5.1_7 设备的分配与回收"></a>5.1_7 设备的分配与回收</h3><p>设备固定属性</p><ul><li>独占设备</li><li>共享设备</li><li>虚拟设备(SPOOLing技术)</li></ul><p>设备分配方式</p><ul><li><p>安全分配</p><p>分配设备后就进行进程调度，直到I&#x2F;O完成。</p><p>保证了一个时段内每个进程只能使用一个设备</p><p>优点：破坏请求和保持条件不会导致死锁</p><p>缺点：CPU和I&#x2F;O设备只能串行(对于一个进程而言)</p></li><li><p>不安全分配</p><p>分配设备后进程可继续执行，之后还可以发出新的I&#x2F;O请求。只有某个I&#x2F;O请求得不到满足时才阻塞。</p><p>优点：一个进程可用多个设备，进程计算任务与I&#x2F;O任务可并行执行。</p><p>缺点：可能死锁。</p></li><li><p>静态分配与动态分配</p><ul><li><p>静态分配</p><p>进程运行前为其分配全部所需资源、运行结束后归还资源</p><p>优点：破坏请求和保持条件，无死锁</p></li><li><p>动态分配</p><p>运行中动态分配</p></li></ul></li><li><p>设备分配管理中的数据结构</p><ul><li><p>系统设备表DCT</p><p>设备类型、设备标识符、设备状态、指向控制器表的指针、重复执行次数或事件、设备队列的队首指针</p></li><li><p>控制器控制表COCT</p><p>控制器标识符、控制器状态、指向通道表的指针设备队列的队首指针、控制器队列的队尾指针</p></li><li><p>通道控制表CHCT</p><p>通道标识符、通道状态、与通道连接的控制器表首址、通道队列的队首指针、通道队列的队尾指针</p></li><li><p>系统设备表SDT</p></li></ul></li><li><p>设备分配的步骤</p><ul><li><p>根据进程请求的物理设备名查找SDT-&gt;DCT分配设备</p></li><li><p>根据DCT找到COCT，将控制器分配给进程</p></li><li><p>根据COCT找到CHCT将通道分配给进程</p></li></ul></li></ul><p>​缺点:物理设备名对用户不透明。若更换物理设备，程序无法执行。同类设备无法交替工作。</p><ul><li>设备分配步骤的改进方法<ul><li>建立逻辑设备名和设备的映射</li></ul></li></ul><h3 id="5-1-8-缓冲区管理"><a href="#5-1-8-缓冲区管理" class="headerlink" title="5.1_8 缓冲区管理"></a>5.1_8 缓冲区管理</h3><ul><li><p>什么是缓冲区？</p><p>缓冲区是一个存储区域，可以由专门硬件寄存器组成(成本高、容量小)也可以利用内存作为缓冲区。</p><p>快表就是利用硬件实现的缓冲区案例。</p><p>设备独立性软件的缓冲区管理指的就是利用内存作为缓冲区。</p></li><li><p>缓冲区的作用</p><ul><li><p>缓和CPU与IO设备之间速度不匹配的矛盾，作为CPU和I&#x2F;O设备的中转站。</p><ul><li><p>减少对CPU的中断频率</p></li><li><p>解决数据粒度不匹配的问题</p></li><li><p>提高CPU与IO设备之间的并行性</p></li></ul></li></ul></li><li><p>缓冲区管理策略</p><p>PS:缓冲区满数据才能被取走，取空之后才能再次放数据。</p><ul><li><p>单缓冲策略</p><p>某进程请求某块设备读入若干块数据，若采用此策略。操作系统在主存中为其分配一个缓冲区</p></li><li><p>双缓冲策略</p><p>某进程请求某块设备读入若干块数据，若采用此策略。操作系统在主存中为其分配两个缓冲区</p></li></ul><p>双&#x2F;单缓冲在通信时的区别：</p><p>单缓冲同一时刻只能实现数据的单向传输。双向可同时。</p><ul><li><p>循环缓冲策略</p><p>多个大小相等的缓冲区链接成一个循环队列</p></li></ul></li><li><p>缓冲池</p><p>由系统中共用的缓冲区组成。这些缓冲区可以分为：空缓冲队列、装满输入数据的缓冲队列、装满输出数据的缓冲队列</p><p>根据一个队列在实际应用中的角色又可分为四种工作缓冲区：</p><p>hin：收容输入数据</p><p>sin:提取输入数据</p><p>hout：收容输出数据</p><p>sout:提取输出数据</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>computer-network</title>
      <link href="/2023/11/03/computer-network/"/>
      <url>/2023/11/03/computer-network/</url>
      
        <content type="html"><![CDATA[<p>计算机网络 </p><span id="more"></span><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="按照用途划分网络"><a href="#按照用途划分网络" class="headerlink" title="按照用途划分网络"></a>按照用途划分网络</h2><ul><li>电信网络：提供电话、电报及传真等服务</li><li>有线电视网络：各类电视节目</li><li>计算机网络：计算机之间传送数据文件</li></ul><p>随着技术发展，上述网络逐渐融为现代计算机网络技术。</p><p>互联网–Internet</p><p>互连网–局部范围互连起来的计算机网络。internet</p><p>互联网基本特点：资源共享、数据通信。</p><p>计算机网络由若干结点和连接这些结点的链路组成。结点可以是计算机也可以是集线器、交换机或路由器等设备。</p><p>计算机网络ICT：计算机技术IT与通信技术CT的结合</p><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><ul><li>边缘部分-资源子网</li><li>核心部分-通信子网</li></ul><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><ul><li>C&#x2F;S</li><li>P2P，微观上依旧是C&#x2F;S</li></ul><h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><ul><li><p>电路交换–面向连接</p><p>建立连接—通信—释放连接</p></li><li><p>分组交换–存储转发技术</p><p>每一个分组都含有地址等控制信息，每个分组也可以独立选择传输路径。</p><p>每个分组额外带的控制信息造成了一定的开销</p><ul><li>数据报：每个分组被独立处理，根据路由选择算法。<strong>IP</strong></li><li>虚电路：建立逻辑连接，每个分组一条路径传输。<strong>X.25、帧中继、ATM</strong></li></ul></li><li><p>报文交换</p><p>整个报文先传送到相邻节点，在查询路由表再转发。</p></li></ul><h2 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h2><ul><li><p>速率–额定速率&#x2F;标称速率</p><p>单位：bit&#x2F;s,注意：在计算机存储中1K&#x3D;2^10^，但在计算机网络中1K&#x3D;10^3^</p><p>k&#x3D;10^3^,M&#x3D;10^6^,G&#x3D;10^9^</p></li><li><p>带宽</p><p>在通信领域带宽指的是某个信号具有的<strong>频带宽度</strong>，单位赫</p><p>在计算机网络中，带宽用来表示网络中某通道传送数据的能力。代表的是“<strong>最高数据率</strong>”，单位：bit&#x2F;s</p></li><li><p>吞吐量</p><p>单位时间内通过某个网络的实际数据量</p></li><li><p>时延</p><p>数据从网络的一段传到另一端所需的时间。包括</p><ul><li><p>发送延迟</p><p>主机或路由器发送数据帧所需要的时间</p><p>发送时延&#x3D;数据帧长度(bit)&#x2F;发送速率(bit&#x2F;s)</p></li><li><p>传播时延</p><p>电磁波在信道中传播一定距离需要花费的时间</p><p>传播时延&#x3D;信道长度(m)&#x2F;电磁波在信道上的传播速率(m&#x2F;s)</p></li><li><p>处理时延</p><p>主机或路由器收到分组时花费一定时间进行处理的时间</p></li><li><p>排队时延</p><p>分组在网络传输时，经过许多路由器，分组在进入路由器后要现在<strong>输入队列</strong>中排队等待处理；在路由器确定转发接口后，还要在<strong>输出队列</strong>中排队转发。这两段排队时间加起来就是排队时延。</p></li><li><p>时延带宽积</p><p>时延带宽积&#x3D;传播时延*带宽</p></li><li><p>往返时间RTT</p><p>双向交互的一次所需的时间。</p></li><li><p>利用率</p><p>信道利用率和网络利用率</p><p>D<sub>0</sub>代表网络空闲时的时延，D表示网络当前的时延，利用率U</p><p>关系：D&#x3D;D<sub>0</sub> &#x2F; (1-U)</p><p>信道或网络的利用率过高会产生非常大的时延</p></li></ul></li></ul><h2 id="计算机网络的非性能特征"><a href="#计算机网络的非性能特征" class="headerlink" title="计算机网络的非性能特征"></a>计算机网络的非性能特征</h2><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可拓展性和可升级性</li><li>易于管理和维护</li></ul><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p>为什么要分层：复杂问题局部化</p><p>网络协议：进行网络中的数据交换而建立的规则、标准或约定。组成：语法，语义、同步</p><p>体系结构：各层及其协议的集合。</p><p>TCP&#x2F;IP协议为四层，大多数教材都采用五层协议。因为最下面的网络接口层并没有具体内容</p><ul><li><p>应用层</p><p>通过进程间的交互来完成特定网络应用。该层协议定义是应用进程间通信和交互的规则。  </p><p>数据单元：<strong>报文</strong></p></li><li><p>运输层</p><p>两台主机中进程之间的通信提供通用的数据传输服务</p><p>主要由TCP和UDP</p><p>采用TCP的数据单位是<strong>报文段</strong>，采用UDP的数据单元是<strong>用户数据报</strong></p></li><li><p>网络层</p><p>为分组交换网上的不同主机提供通信服务。将上层产生的数据封装成分组或包进行传送。使用IP，因此分组也叫做<strong>IP数据报</strong></p></li><li><p>数据链路层</p><p>将上层数据组装成帧，在两个相邻间的链路上传送帧。每一帧都包含数据和必要控制信息。</p></li><li><p>物理层</p><p>数据单位：bit</p><p>确定特性</p></li></ul><p>OSI参考模型把对等层次之间传送的数据单元称为该层的<strong>协议数据单元PDU</strong></p><h2 id="OSI七层参考模型各层功能"><a href="#OSI七层参考模型各层功能" class="headerlink" title="OSI七层参考模型各层功能"></a>OSI七层参考模型各层功能</h2><ul><li>应用层—各种应用程序</li><li>表示层—<strong>数据压缩和加密解密</strong></li><li>会话层—为通信双方指定通信方式，创建、注销会话</li><li>传输层—提供可靠&#x2F;不可靠的<strong>端到端传输</strong></li><li>网络层—<strong>逻辑寻址，路由选择</strong></li><li>数据链路层—封装成帧，<strong>节点到节点的传输</strong>，差错控制</li><li>物理层—物理媒介上传输bit流</li></ul><p>PS：节点到节点：相邻节点之间的传输</p><p>​端到端：目标节点和源节点的传输，中间可能经过多次节点到节点传输</p><h2 id="网络互联设备"><a href="#网络互联设备" class="headerlink" title="网络互联设备"></a>网络互联设备</h2><p>物理层–中继器(repeater)，集线器(Hub)—放大信号，延长传输距离</p><p>数据链路层–网桥，交换机—基于目的MAC地址转发数据帧</p><p>网络层—路由器，三层交换机—基于目的IP地址转发数据报</p><p>四层及以上–网关—基于传输层，应用层进行控制</p><p>传统交换机架构每台设备都具有转发层面和控制层面</p><p>网络演进：中继器，集线器—&gt;二层交换机—&gt;三层交换机—&gt;多业务交换机—&gt;可编程交换机SDN</p><p>中继器</p><ul><li><p>​两个接口，集线器：多接口</p></li><li><p>​工作原理—从一个接口进入的数据，进行信号放大，从其他所有接口进行泛洪</p></li><li><p>​问题–产生环路，广播风暴。数据扩散，安全威胁</p></li></ul><p>交换机</p><ul><li><p>​可构建数据交换专用通道，网桥为两口交换机。</p></li><li><p>​一般来说交换机指的是二层以太网交换机</p></li><li><p>​交换机寻址—交换机有一MAC地址表(MAC地址、接口、VLAN)。数据传送中，若MAC地址无目的地址信息，则广播，目的主机收到后封装回复帧返回给交换机。</p></li></ul><p>路由器</p><ul><li><p>​实现跨网段，跨VLAN通信</p></li><li><p>​三层交换机将路由器功能集成到了交换机内部</p></li><li><p>​路由器和三层交换机的区别</p></li></ul><table><thead><tr><th></th><th>路由器</th><th>三层交换机</th></tr></thead><tbody><tr><td>应用场景</td><td>网络出口，骨干网</td><td>LAN，园区网，MAN</td></tr><tr><td>成本</td><td>高</td><td>低</td></tr><tr><td>功能</td><td>NAT</td><td>VLAN，STP</td></tr><tr><td>性能</td><td>较低</td><td>高</td></tr></tbody></table><p>网关</p><ul><li><p>网关是互联网络中操作在OSI传输层之上的设施</p></li><li><p>主要功能</p><p>连接不同协议子网</p><p>对互不兼容的高层协议进行抓换</p><p>对传输层、会话层、表示层、应用层进行翻译和转换</p></li><li><p>网关类型</p><p>协议网关–不同网络区协议转换(路由器)</p><p>应用网关–不同数据格式间翻译数据(数据中心)</p><p>安全网关–保护作用(防火墙)</p></li></ul><h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><p>数据在通信线路上的传输方式一般都是串行传输</p><h2 id="数据通信系统"><a href="#数据通信系统" class="headerlink" title="数据通信系统"></a>数据通信系统</h2><ul><li><p>源系统</p><p>源点&#x2F;信源</p><p>发送器：源点生成的数字比特流要通过发送器编码后才能在传输系统中传输。</p></li><li><p>传输系统</p></li><li><p>目的系统</p><p>接收器：将传输系统传送过来的信号经过接收器转换后能被目的设备处理的信息。</p><p>终点&#x2F;信宿</p></li></ul><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul><li>模拟信号&#x2F;连续型号</li><li>数字信号&#x2F;离散信号—计算机传送的信号，高低脉冲</li></ul><h2 id="数据通信方式"><a href="#数据通信方式" class="headerlink" title="数据通信方式"></a>数据通信方式</h2><ul><li>单工–电视，广播</li><li>半双工–Hub(集线器)，WI-Fi</li><li>全双工–交换机&#x2F;电话</li></ul><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>异步传输</p><ul><li>各个字符分开传输，字符之间插入同步信息。典型的是插入起始位和结束位。HDL是典型异步传输，起始位与结束位都是“01111110”</li></ul><p>同步传输</p><ul><li>发送方在传送数据之前先发送一串同步字符SYNC。接收方检测到两个以上的SYNC就确认进入同步状态。传输效率高，在短距离高速传输中适用。</li></ul><h2 id="调制方式"><a href="#调制方式" class="headerlink" title="调制方式"></a>调制方式</h2><p>基带信号：</p><p>来自信源的信号，往往包含较多低频成分，甚至是直流成分。许多信道不能传输这种低频分量或直流分量，所以需要发送器来进行调制。</p><ul><li><p>基带调制&#x2F;编码</p><p>仅仅对波形进行变换，变换后仍然是基带信号。把数字信号转换为另一种形式的数字信号</p></li><li><p>带通调制</p><p>使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号。经过载波调制后的信号称为带通信号。</p></li></ul><p>由此可见，计算机产生的信号是数字信号。</p><p>常用的的基带调制&#x2F;编码方式：</p><p>​–双向码：每一位都要有电平转换，一高一低。</p><p>​–曼彻斯特与差分曼彻斯特都具有自定时和检查错误的功能。</p><p>​优：将失踪和数据包含在信息数据流中，也称为同步码</p><p>​缺：编码效率都是50%，数据速率是码元速率的一半。</p><ul><li><p>不归零</p></li><li><p>归零制</p></li><li><p>曼彻斯特</p><p>双相码，每个bit中间均有一个跳变。波形代表高低电平需要自定义。第一个编码自定义。常用于以太网。</p></li><li><p>差分曼彻斯特</p><p>双相码，在两个编码中间，有跳变表示0，无跳变表示1。常用于令牌环网。</p></li><li><p>4B&#x2F;5B编码</p><p>每发送4bit数据，转换为5bit，再转换为不归零码。多义词解决同步问题。</p><p>数据效率为80%，用于百兆以太网</p><p>类似的编码还有8B&#x2F;10B，数据效率80%，用于千兆以太网。64B&#x2F;66B，效率97%，用于万兆以太网。</p></li></ul><p>带通调制方式：</p><ul><li><p>幅度键控(ASK)：用载波的两个不同振幅表示0，1.高低</p></li><li><p>频移键控(FSK)：用载波的两个不同频率表示0，1.快慢</p></li><li><p>相移键控(PSK)：用载波的起始相位变化表示0，1.形状(正弦余弦)</p></li><li><p>正交振幅调制(QAM)：把两个幅度相同但相位差90%的模拟信号组成一个模拟信号–点阵图</p><p>码元只取两个相位值叫2相调制。码元取4个相位称为4相调制。则N&#x3D;2，N&#x3D;4。</p><p>ASK默认2相调制，4ASK使用4相调制。DPSK使用2相调制。QPSK使用4相调制。</p><p>DPSK也指差分曼彻斯特编码</p><p>BPSK&#x3D;2PSK&#x3D;PSKA.</p></li></ul><p>脉冲编码调制(PCM)</p><p>​用编码解码器把模拟数据变换为数字信号的过程叫模拟数据的数字化，常用数字化技术就是脉冲编码调制技术，简称脉码调制。</p><p>​三步骤：采样，量化、编码。</p><p>PCM计算：</p><p>对声音进行数字化时，由于语音最高频率为4KHz，所以采样频率是8KHz(2fmax),对语音样本用128个的等级量化。因而每个样本用7bit表示(log<sub>2</sub>128&#x3D;7),在数字信道传输这种数字化后的语音信息的速率是7*8000(n * 2fmax)&#x3D;56kbps。</p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>信道带宽W</p><p>模拟信道—f2、f1代表信道能通过的最高和最低频率，单位HZ。</p><p>​w&#x3D;f2-f1</p><p>数字信道—带宽为信道能够达到的最大数传输速率bit&#x2F;s</p><p>码元：一个数字脉冲(时钟周期)称为一个码元</p><p>码元速率：单位时间内信道传送的码元个数。如果码元宽度(时钟周期)为T，则码元速率(波特率)为B&#x3D;1&#x2F;T(Baud)</p><p>一个码元携带信息量n位与码元种类数(N)的关系为n&#x3D;log<sub>2</sub>N</p><p>​PS:n&#x3D;2,N&#x3D;4—-00&#x2F;01&#x2F;10&#x2F;11</p><p>信噪比(dB)&#x3D;10 log<sub>10</sub>(S&#x2F;N)(dB)</p><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>研究不理想(有噪声)的信道中，若信道带宽为W。</p><p>极限信息速率C&#x3D;W log<sub>2</sub>(1+S&#x2F;N)(bit&#x2F;s)&#x2F;&#x2F;S&#x2F;N指的是信噪比</p><p>分贝与信噪比关系：dB&#x3D;10log<sub>10</sub>S&#x2F;N</p><p>例：dB&#x3D;10&#x3D;10log<sub>10</sub>S&#x2F;N</p><p>​两边各除10，1&#x3D;log<sub>10</sub>S&#x2F;N</p><p>​S&#x2F;N&#x3D;10</p><h3 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h3><p>采样定理：若模拟信号最高频率为fmax，若以大于等于2fmax的采样频率对其进行采样。则采样的到的离散信号序列就能完成恢复出完整数据。</p><p>研究理想环境(无噪声)的信道中,若信道带宽为W，最大码元速率为B&#x3D;2W(baud)</p><p>极限数据速率为R&#x3D;B*log<sub>2</sub>N&#x3D;2W * log<sub>2</sub>N</p><h3 id="信道延迟"><a href="#信道延迟" class="headerlink" title="信道延迟"></a>信道延迟</h3><p>与源端和宿端距离有关，还和信道中传播速率有关</p><p>总延迟&#x3D;线路延迟+发送延迟</p><p>线路延迟&#x3D;传输距离&#x2F;传播速度</p><p>发送延迟&#x3D;数据帧大小&#x2F;速率</p><p>常见传输介质的传播速度</p><p>— 1s&#x3D;1000 ms(毫秒) &#x3D; 1000*1000us(微秒)  &#x3D; 1000 * 1000 * 1000ns(纳秒)</p><p>— 1Gb&#x2F;s&#x3D;10^3^Mb&#x2F;s&#x3D;10^3^*10^3^ Kb&#x2F;s&#x3D;10^3^ * 10^3^ * 10^3^ * 10^3^ bit&#x2F;s</p><ul><li>光速：30 0000km&#x2F;s&#x3D;300m&#x2F;us</li><li>电缆(传播速率为光速的67%)：20 0000km&#x2F;s&#x3D;200m&#x2F;us</li><li>卫星信道时延大约270ms(来回540ms)</li></ul><p>例 ：</p><p>1000m电缆线路延迟</p><p>1000m &#x2F; 200m&#x2F;us&#x3D;5us</p><p>100Mbit&#x2F;s线路，发送1000字节数据，发送延迟为</p><p>字节转换为bit，M转换为bit</p><p>1000*8(bit) &#x2F;100 * 10^6^bit&#x2F;s&#x3D;8&#x2F;10^5^ s&#x3D;8&#x2F;10^5^ * 10^6^ us&#x3D;80us</p><h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><p>导引型传输媒体</p><ul><li><p>双绞线</p><p>由多对绝缘铜导线两两相互缠绕而成</p><p>缠绕目的：降低干扰</p><p>数据传输：</p><p>​100M—4根2对</p><p>​1000M–8根</p><p>可以利用“分线器”将1000M传输速率的网线拆为两根100M的网线</p><p>网口：RJ-45，电话口：Rj11</p><p>当千兆网线实际速度只有百兆时，可能是网线故障(某根导线损坏)</p><p>TIA&#x2F;EIA双绞线规格</p><ul><li>5类：100M以太网，短距离可千兆</li><li>超5类、6类: 可用于1G以太网传输</li><li>超6类:1G以太网传输</li><li>7类：10G以太网传输，必须是屏蔽双绞线</li></ul><p>STP–绝缘套管中外层由铝箔包裹，减小辐射干扰。价格高</p><p>UTP–价格低</p></li><li><p>同轴电缆</p></li><li><p>光纤</p><p>利用光在玻璃或塑料纤维中的全反射原理而达成的光传导工具</p><p>光缆：多根光纤和塑料保护套管及塑料外皮构成。外形为黑色线缆</p><p>光猫：光纤传输的是光信号，计算机发送与传输的是电信号，所以要用光猫来转换。</p><p>当需要传输的距离超过100km时，使用中继器等中间设备。</p><p>光接口于光纤连接需要使用光模块(区分单模光模块与双模光模块)</p><p>光纤分类</p><ul><li><p>单模(LX&#x2F;LX&#x2F;2X)</p><p>只允许一种模式的光信号在其中传播，可用于大容量、长距离通信，价格高。波长1210nm~1550nm。</p><p>芯径8.3um，外层125um。</p><p>颜色黄色，光源LD、LED(光谱线较窄的)，</p><p>距离—LX：10km，LH&#x2F;2X：10~120km</p></li><li><p>多模(SX)</p><p>允许多种模式光信号传播，较小容量、短距离传输，价格便宜。波长850nm~1300nm</p><p>芯径62.5um，外层125um</p><p>颜色橘黄、浅绿色</p><p>光源：LED、LD</p><p>距离：220m~550m</p><p>反射方式：渐变反射，阶跃&#x2F;突变反射</p></li></ul><p>光纤连接方式</p><ul><li>专业设备将两根光纤熔接在一起</li><li>使用光纤连接器，用于光纤跳线式或是不同光纤连接器的转换</li></ul><p>跳线与尾纤</p><ul><li>双绞线跳线：带水晶头的网线</li><li>光纤跳线：带有光纤连接器与保护层的光纤</li><li>尾纤：只有一头有光纤连接器的光纤，可以用来熔接</li></ul></li><li><p>架空明线</p></li></ul><p>非导引型传输媒体</p><ul><li>微波—300MHz~300GHz 高频波段。用于雷达，飞机导航</li><li>无线电波–500kHz~1000MHz,能量最小，波长最高，频率最低。用于广播电视和无线通信</li><li>红外线</li><li>激光</li></ul><h2 id="复用技术"><a href="#复用技术" class="headerlink" title="复用技术"></a>复用技术</h2><p>多路复用技术</p><p>把多个低速的信道组成一个高速的信道技术。</p><p>多路器(MUX):</p><ul><li>多路复用器：发送端将多个低带宽信号组合为一个高带宽信号。运营商端复用设备(OLT)</li><li>多路分配器：接收端高带宽分解</li></ul><p>信道复用技术</p><ul><li><p>频分复用—ADSL，无线电广播</p><p>占用不同频带</p></li><li><p>时分&#x2F;同步时分复用–T1&#x2F;E1，WIFI，SONET&#x2F;SDH，TDD，LED</p><p>不同事件占用相同频带</p></li><li><p>统计时分&#x2F;异步时分复用</p><p>将低速的分布在多个频带的数据通过集中器合并到一个频带中。</p></li><li><p>波分复用</p><p>光的频分复用</p></li><li><p>码分复用&#x2F;码分多址(CDMA)</p><p>各用户挑选不同码型，可将数据合并在一起发送。</p></li></ul><p>T1&#x3D;1.5444M</p><p>E1&#x3D;2.048M</p><h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><p>用户想要连接互联网，必须先连接到某个ISP，以便获得上网所需的IP地址。</p><ul><li><p>ADSL非对称数字用户线</p><p>数字技术对现有的模拟电话用户线进行改造，使之承载宽带数字业务</p></li><li><p>光纤同轴混合网(HFC网)</p><p>机顶盒连接在同轴电缆和用户的电视机之间，使现有的模拟电视机能够接收数字电视信号。</p></li><li><p>FTTx技术</p><p>“Fiber to the x”光纤到x</p></li></ul><h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><h2 id="信道类型"><a href="#信道类型" class="headerlink" title="信道类型"></a>信道类型</h2><ul><li>点对点信道</li><li>广播信道</li></ul><p>链路和数据链路</p><p>链路指的是物理线路(有线或无线)，数据链路指的是链路加上通信协议，最常用的就是使用网络适配器(网卡)来实现这些协议。</p><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><ul><li>数据前后加上首部和尾部。首部和尾部重要功能就是帧定界—定界符SOH、EOT。数据部分长度上线–最大传送单元MTU</li></ul><p>前面7(先导字段)+1(帧开始标识)字节用于时钟同步，不算入帧长。</p><p>数据长度46~1500字节</p><p>校验位4字节</p><p>最小帧长：目的地址(6Byte)+源地址(6)+长度(2)+数据(46)+校验和(4)&#x3D;64Byte</p><p>最大帧长：1518Byte</p><p>最大利用率：1500&#x2F;1518</p><p>最小利用率：46&#x2F;64</p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><ul><li>保证数据部分中不出现帧定界符，加上转义字符ESC，该种方法称为字节填充或字符填充</li></ul><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>误码率BER&#x3D;传输错误的比特&#x2F;传输比特总数</p><ul><li><p>奇偶校验</p><p>加一位校验位。使码中1的个数为奇数(奇校验)或偶数(偶校验)</p></li><li><p>海明码(可检错也可纠错)</p><p>海明距离：两个码字之间不同的比特数</p><p>海明码原理：加入校验码，码距均匀拉大，当某位出错时会引起几个校验位值改变。</p><p>海明不等式：校验码个数为K，可以表示2^k^个信息，1个信息用来表示“没有差错”。其余2^k^-1表示数据中存在错误。若满足2^k^-1&gt;&#x3D;m+k（m为信息位)。则理论上k个校验码即可判断出哪一位出错。</p><p>海明编码：第2^i^位时校验位，其余位存放数据。(i取值[0~正无穷])</p></li><li><p>CRC循环冗余校验</p><ol><li>判断校验位数，生成多项式的最高次方时几，校验位就是几位。</li><li>补齐数据位后面的0</li><li>提取生成多项式系数</li><li>第二步结果除以(异或除)第三步结果取余数即为CRC校验码。(原数不够位，前补0)</li></ol><p>例—生成多项式G(x)&#x3D;x^4^+x+1,信息码10111</p><ol><li><p>检验位4位</p></li><li><p>101110000</p></li><li><p>G(x)&#x3D;x^4^+x+1&#x3D;1*x^4^+0 * x^3^+0 * x^2^+1 * x^1^+1 * x^0^—&gt;10011</p></li><li><p>101110000 异或除  10011  —&gt;商10000，余1100</p><p>CRC校验码为1100</p></li></ol></li></ul><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><ul><li>用户和ISP进行通信时所使用的数据链路层协议</li></ul><h2 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h2><p>以太网就是局域网的一款产品</p><ul><li><p>DIX V2</p></li><li><p>IEEE 802.3</p><p>IEEE802委员会将数据链路层拆分为两个子层：逻辑链路控制LLC和媒体接入控制MAC。MAC与接入的传输媒体有关。</p><p>MAC层硬件地址，48位。用来广播识别目的地的根据</p></li></ul><h2 id="城域网基础"><a href="#城域网基础" class="headerlink" title="城域网基础"></a>城域网基础</h2><p>承载以太网技术规范业务类型之一—E-LAN(以太局域网服务)</p><p>​由运营商建立一个城域以太网，在用户以太网之间提供多点对多点的第二层连接，任意两个用户以太网之间都可以通过城域以太网通信。</p><p>​IEEE802.1ad的运营商网桥协议，被称为Q-in-Q技术。实际上是把用户VLAN嵌套在城域以太网的VLAN中传送，也就是打了两层VLAN标签。</p><h2 id="适配器–网络接口卡NIC的作用"><a href="#适配器–网络接口卡NIC的作用" class="headerlink" title="适配器–网络接口卡NIC的作用"></a>适配器–网络接口卡NIC的作用</h2><ul><li>串行&#x2F;并行的转换(计算机并行，网络传输串行)</li><li>对数据进行缓存(网络数据带宽和计算机总线的数据率不同)</li><li>在操作系统安装驱动程序</li><li>实现以太网协议(市面上一般网卡都是使用以太网协议)</li></ul><h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h2><p>若连续碰撞16次，则认为网络繁忙或堵塞，不再尝试发送。</p><p>三种监听方法</p><ul><li>非坚持型监听算法：后退随机时间</li><li>1-坚持型监听算法：继续监听，不等待。介质利用率和冲突概率都高</li><li>P-坚持型监听算法</li></ul><p>冲突检测原理</p><p>​载波监听能减小冲突概率，不能杜绝。</p><ol><li>发送期间同时接收，并与原本存储的数据比较</li><li>若结果一致，则代表没有因碰撞而导致数据错误，重复1</li><li>若结果不一致，有冲突，停止发送。并发送干扰信号(Jamming)使所有站都停发。</li><li>等待随机一段时长，重新监听</li></ol><p>等待随机一段时间实现采用—二进制指数退避算法</p><p>​随机时间&#x3D;t * Random[0~2^k^-1]</p><p>​t：读作涛，为固定值</p><p>​k&#x3D; min[重传次数，10  ]</p><p>以太网发送的数据都使用曼彻斯特编码</p><p>使用半双工通信</p><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul><li>实现以太网广播</li><li>工作在物理层，实现简单地转发比特。</li></ul><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><ul><li><p>物理层扩展</p><p>利用集线器连接</p><p>使用光纤</p></li><li><p>数据链路层扩展</p><p>网桥–收到地帧根据其目的地址进行转发和过滤。</p><p>第二层交换机(交换式集线器，以太网交换机、二层交换机)—多接口网桥。<strong>工作在全双工方式</strong>，具有并行性。多采用存储转发方式进行转发(也有直通方式地，即不检错就直接转发)，内部维护一“帧交换表”。</p><p>帧交换表有自学习功能，过程需要解决广播风暴—使用生成树协议STP</p></li></ul><h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><p>不同VLAN通信必须经过三层设备：路由器，三层交换机，防火墙</p><p>实质是在以太网帧中插入一个标识符—802.1Q标签，以太网交换机在传输数据的时候会根据VLAN标识来传输数据。交换机添加和删除VLAN标签过程由专门硬件自动实现，不会造成太大延迟。</p><p>交换机端口类型</p><ol><li>Access</li><li>Trunk</li></ol><p>标签(4Byte):</p><ul><li>TPID(16bit)</li><li>PRI优先级(3):当多个帧等待发送，按优先级发送</li><li>CFI(1)</li><li>VID(12):VLAN标识，最多可表示2^12^&#x3D;4096个VLAN，0用来识别优先级，4095保留。实际可用4094.</li></ul><p>交换机VLAN划分</p><ul><li>静态–基于交换机接口</li><li>动态–基于MAC地址，策略，网络层协议，网络层地址</li></ul><p>VLAN作用</p><ul><li>控制网络流量，划分广播域，减少冲突域。提高网络带宽利用率。</li><li>提高安全性</li><li>突破地理位置</li></ul><p>冲突与和广播域</p><ul><li>一个中继器和集线器是一个冲突域</li><li>一个VLAN为一个广播域</li><li>交换机的一个接口为一个冲突域</li></ul><p>冲突域是指连接在同一工匠介质上所有节点的集合，所有节点竞争同一带宽。一个节点发出报文，其余节点都可以收到，无论单播、组播、广播。</p><p>交换机可隔离冲突域，每个接口相当于一个独立的冲突域。</p><p>广播域指的是广播报文所能到达的整个访问范围。路由器的每个接口时一个广播域。交换及连接的节点属于同一广播域。</p><h2 id="帧中继协议"><a href="#帧中继协议" class="headerlink" title="帧中继协议"></a>帧中继协议</h2><p>工作在数据链路层，提供虚电路服务。本地表示DLCI</p><p>可提供面向连接的服务。</p><p>只做检错和拥塞控制，无流量控制和重传机制。</p><p>帧长可变1600~4096Byte</p><p>速率2-45Mb</p><h2 id="ISDN与ATM"><a href="#ISDN与ATM" class="headerlink" title="ISDN与ATM"></a>ISDN与ATM</h2><p>一种通用的电信网络，实现音频、视频、数据业务放在同一个网络上传输。</p><p>ISDN：综合数字业务网</p><p>​基本速率BRI：144kb</p><p>​基群速率PRI：2.048Mb</p><p>ATM：宽带ISDN</p><p>​ATM的网络层以虚电路提供面向连接</p><p>​典型速率150M</p><p>​信元交换，信元53Byte</p><h2 id="HDLC"><a href="#HDLC" class="headerlink" title="HDLC"></a>HDLC</h2><p>(高级数据链路控制)协议，面向bit的同步链路控制协议—实现同步？</p><p>使用CRC-16，CRC-32校验，帧边界“0111 1110”</p><p>HDLC帧格式</p><ul><li><p>中间有1字节控制字符</p></li><li><p>控制字符</p><p>I帧–信号帧：用于承载数据和控制，第一位为0</p><p>S帧–监控帧：用于差错控制与流量控制，前两位为10</p><p>U帧–无编号帧：提供控制功能，也可以承载数据</p></li><li><p>帧类型</p><p>SREJ：拒绝接收，选择重发</p><p>REJ：拒绝接收，回退N帧重发</p><p>RNR：接收未准备好</p><p>RR：接收准备好</p></li></ul><p>最小帧长计算</p><p>Lmin&#x3D;2R*d&#x2F;v—注意单位换算</p><p>R为网路数据速率，d为最大距离，v为传播速度</p><p>不冲突条件：发送时间&gt;&#x3D;传送时间+确认时间</p><h2 id="生成树技术"><a href="#生成树技术" class="headerlink" title="生成树技术"></a>生成树技术</h2><p>交换机单链路上行存在单点故障，任意链路或设备出现故障都可能断网</p><p>冗余拓扑可用解决单点故障，但是可能导致二层环路：广播风暴、MAC表振荡</p><p>广播风暴现象：网络慢，指示灯高速闪烁。CPU利用率高，CLI卡顿。MAC表持续更改。</p><p>生成树技术可以通过逻辑阻塞特定端口，从而打破环路。</p><p>网桥ID：8字节(2字节优先级，6字节MAC地址)，桥优先级为32768，可以手动修改。</p><p>STP选举：</p><ul><li>确定一个根桥，根据网桥ID中的优先级和MAC地址更小来确定。BPDU报文选举根桥、</li><li>确定其他网桥&#x2F;交换机的根端口RP</li><li>每个段选一个指定端口</li><li>选举非指定端口</li></ul><img src="/2023/11/03/computer-network/Users\yongji\AppData\Roaming\Typora\typora-user-images\image-20230921162712882.png" alt="image-20230921162712882" style="zoom:25%;"><p>几种生成树协议</p><ul><li>802.1d STP ：  慢、拓扑收敛30~50秒</li><li>802.1w  RSTP：快，6s内完成收敛</li><li>802.1s  MSTP：多个VLAN负载均衡</li></ul><h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h1><h2 id="IP网际协议"><a href="#IP网际协议" class="headerlink" title="IP网际协议"></a>IP网际协议</h2><p>网络层使用的中间设备是路由器，再之上的层次使用的中间设备是网关。许多有关TCP&#x2F;IP的文献曾经将网络层使用的路由器称为网关。</p><p>路由器必须有两个及以上的IP地址，意即至少连接两个网络。则网络层以下的网络都是一个网络，通过中间设备连接的不同局域网组成的网络。局域网内的主机网络号号都相同。</p><h3 id="IP地址划分"><a href="#IP地址划分" class="headerlink" title="IP地址划分"></a>IP地址划分</h3><ul><li>A类：网络号1~126</li><li>B类：网络号128.1~191.255</li><li>C类：网络号192.0.1~233.255.255</li><li>D类：多播地址</li><li>E类：保留</li></ul><p>特殊IP</p><ul><li>全零–主机端：DHCP分配过程中，全零代表本机；服务器端：本机所有IPv4地址；路由：默认路由</li><li>全1—受限广播地址</li><li>169.254.0.0&#x2F;16：DHCP服务器出现故障或响应超时无法上网</li><li>127.0.0.0&#x2F;8 本地环回地址</li><li>私有地址：A：10.0.0.0&#x2F;8；B：172.16.0.0&#x2F;12；C：192.168.0.0&#x2F;16</li></ul><h3 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h3><p>首部+数据两部分组成</p><p>首部&#x3D;固定部分(20Byte) + 可变部分</p><p>固定部分：</p><ul><li><p>版本(4bit)</p></li><li><p>首部长度IHL(4bit)–最小值5，最大值15。单位4字节。所以首部最长60Byte</p></li><li><p>区分服务TOS(8)—Qos字段</p></li><li><p>总长度(16)–数据报(<strong>包括首部</strong>)的总长度为2^16^-1&#x3D;65535字节</p></li><li><p>标识(16)–数据报的序号，分片后各数据报片使用的是同一个标识</p></li><li><p>标志(3)—MF(后面还有分片)&#x2F;DF(后面没有分片)</p></li><li><p>片偏移(13)</p></li><li><p>生存时间TTL(8)—每经过一个路由器就消耗一次，可以使用秒或跳数作单位。</p></li><li><p>协议(8)</p><p>1—ICMP</p><p>17–UDP</p><p>6–TCP</p></li><li><p>首部校验和(16)—仅计算IP头部，当TTL发生变化后重新计算</p></li><li><p>源地址(32)</p></li><li><p>目的地址(32)</p></li></ul><h3 id="IP分片计算"><a href="#IP分片计算" class="headerlink" title="IP分片计算"></a>IP分片计算</h3><p>设一数据报总长度3820Byte，其数据部分为3800字节长(使用固定首部)，需要分片为长度不超过1420字节的数据报片，因其固定首部20Byte。因此数据报片的数据部分不能超过1400Byte。于是分为3个数据报片，其数据长度分别为1400，1400，1000Byte</p><p>数据报片1：总长度1420，片偏移0&#x2F;8&#x3D;0，MF&#x3D;1，DF&#x3D;0</p><p>数据报片2：总长度1420，片偏移1400&#x2F;8&#x3D;175，MF&#x3D;1，DF&#x3D;0</p><p>数据报片3：总长度1020，片偏移2800&#x2F;8&#x3D;350，MF&#x3D;0，DF&#x3D;0</p><h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><p>只要路由不在我的路由表中，就直接交给默认路由。</p><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><p>背景：IP地址空间利用率低，AB类太多，C类太少；两级IP地址不够灵活。</p><p>解决方法：在原本的两级IP地址–网络号:主机号上再将主机号划分为子网号:主机号。于此构成三级IP地址</p><center>网络号：子网号：主机号</center><p> 划分子网后路由器寻址问题</p><p>不是本单位的网络仍然根据IP数据报的目的网络号找到连接在本单位的路由器，本单位路由器收到后再按目的网络号和子网号找到目的子网，再交付。</p><p>路由器根据子网掩码和目的地址与运算即可得出目的地址属于自己连接的哪一个子网—网络地址。</p><p>即便不划分子网也可以使用子网掩码以此来区分该网络的地址是哪一类IP。</p><h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><p>主机或路由器已经知道了目的主机的IP地址，在将数据传到数据链路层的时候，需要知道目的地址的MAC地址来封装成帧(在局域网内，传送数据需要用到该主句的MAC地址)，使用ARP完成此功能。注意：ARP解决同一个局域网上的主机或路由器的映射问题。当不处在同一网络的ARP就需要路由器的帮助。</p><p>ARP协议可归为网络层或者数据链路层。</p><p>每一台主机都设有一个<strong>ARP高速缓存</strong>(ARP表)来保存本局域网上各个主机和路由器IP地址与MAC地址之间的映射。</p><p>如果主机A向本局域网的主机B发送IP数据报时，就先在其高速缓存中查看有无主机B的映射。如果有：则交给<strong>数据链路层封装成帧</strong>。如果没有：</p><ul><li>A主机的ARP进程向本局域网上<strong>广播</strong>发送一个ARP request</li><li>B主机收下这个ARP请求分组，先在自己的高速缓存中写入映射，再<strong>单播</strong>ARP reply返回响应</li><li>A主机收到后，在高速缓存中写入映射。</li></ul><p>ARP对保存在高速缓存的每一个映射项目都设置生存周期，超过就删去。</p><p>代理ARP：同一网段，不同物理地址网络上的计算机之间可通过ARP代理实现相互通信。</p><h2 id="网络控制报文协议ICMP"><a href="#网络控制报文协议ICMP" class="headerlink" title="网络控制报文协议ICMP"></a>网络控制报文协议ICMP</h2><p>协议号为1</p><p>目的：用于传送有关通信问题的消息，更有效转发IP数据报和提高交付成功的机会。</p><p>ICMP报文封装在<strong>IP数据报</strong>的数据部分中，不保证可靠传输，32bit。用来传递差错控制和查询信息</p><p>报文种类</p><ul><li>ICMP差错报告报文—路由器向源主机反馈的IP数据报发送失败原因</li><li>ICMP询问报文—主机或路由器向一个主机的询问</li></ul><p>ICMP的应用</p><ul><li>Ping</li><li>traceroute&#x2F;tracert</li></ul><h2 id="网关协议"><a href="#网关协议" class="headerlink" title="网关协议"></a>网关协议</h2><p>​Internet中的路由器叫做IP网关。网关执行复杂的路由信息，需要大量及时的路由信息。网关协议就是用于网关之间交换路由信息的协议</p><p>路由器或其他三层设备收到一个IP数据报后会查看数据报中的目的IP地址，根据自身维护的路由表进行匹配最佳路由。之后将数据报发送给下一跳。</p><p>路由器工作原理</p><ol><li><p>建立并维护路由表(RIB)，表项可分为</p><ul><li>直连路由–路由器本地接口所在网段</li><li>静态路由–手工配置路由条目–网络大工作量大，无法响应拓扑变化</li><li>动态路由–通过动态路由协议学习到的路由</li></ul></li><li><p>根据路由表进行数据转发</p><p>路由表表项：目的网段，协议，优先级，开销，标志位，下一跳，出接口</p><p>查看路由表：display ip routing table</p><p>静态路由配置：ip route-static 网络号 掩码   下一跳IP地址</p><p>默认路由配置：ip route-static 0.0.0.0 下一跳IP地址—用处：网络出口路由器</p></li></ol><p>动态路由协议</p><ul><li><p>距离矢量协议：RIP，BGP</p><p>关心自身与网络之间的距离(跳数)</p><p>关心应该往哪个方向或接口转发数据包</p></li><li><p>链路状态协议：OSPF，IS-IS</p></li></ul><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3><p>​自治系统是由同构型的网关连接的Internet，这样的系统往往是由一个网路管理中心控制的。自治系统内部的网关之间执行内部网关协议(IGP)，互相交换路由信息。</p><p>​一个互联网也可能由不同的自治系统互联而成，不同的自治系统可能采用不同的路由表，不同的路由选择算法。不同自治系统之间使用外部网关协议(EGP)交换路由信息。</p><h3 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h3><p>早期有一个外部网关协议叫EGP，最新的外部网关协议叫做BGP</p><h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><p>BGP 4是一种动态路由发现协议，通过TCP 179端口建立连接</p><p>四个报文</p><ul><li>open–建立领层关系</li><li>update–发送新的路由信息</li><li>keepalive–对open的应答，周期性确认领层关系</li><li>notification–报告检查到的错误</li></ul><h3 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h3><p>​网关协议也叫做路由协议，因为自治系统内部或外部之间最主要的事情就是互换路由信息。常见内部路由协议包括RIP，OSPF，IS-IS</p><h4 id="RIP-路由信息协议"><a href="#RIP-路由信息协议" class="headerlink" title="RIP(路由信息协议)"></a>RIP(路由信息协议)</h4><p>RIPv1和RIPv2的对比</p><p>v1：有类，不携带子网掩码</p><p>V2：无类，携带子网掩码</p><ul><li>RIP是一种分布式的基于距离向量的路由选择协议</li><li>距离也称为“<strong>跳数</strong>”，每经过一个路由器，跳数就+1。</li><li>RIP允许一条路径最多包含15个路由器，因此距离等于<strong>16时不可达</strong>。可见RIP只适用于小型互联网。</li><li>RIP仅和相邻路由器交换路由信息，按固定时间间隔交换。</li><li>30s周期性更换路由表，180s(包含前30s)无更新表示不存在，300s删除路由(包含前180s)</li></ul><h4 id="OSPF-开放式最短路径优先协议"><a href="#OSPF-开放式最短路径优先协议" class="headerlink" title="OSPF(开放式最短路径优先协议)"></a>OSPF(开放式最短路径优先协议)</h4><p>路由器之间交互的是链路状态信息，采用SPF(dijkstra算法)计算最短路径，支持VLSM。支持手工路由汇总。</p><p>特点：</p><ul><li>不会产生环路</li><li>允许网络被划分为区域来管理，减小对路由器内存和CPU的消耗，降低网络带宽占用</li><li>OSPF cost：100M接口带宽，一条OSPF路由的cost由该路由从起源一路到达本地的所有入接口cost值得总和。</li><li>分层路由：Area 0.0.0.0或Area 0表示骨干区域。</li><li>特殊组播地址：224.0.0.5运行OSPF协议的路由器；224.0.0.6运行OSPF指定&#x2F;备用指定路由器DR&#x2F;BDR</li><li>采用IP协议封装，以目标地址224.0.0.5发送到OSPF路由器</li></ul><h4 id="IS-IS-中间系统到中间系统"><a href="#IS-IS-中间系统到中间系统" class="headerlink" title="IS-IS(中间系统到中间系统)"></a>IS-IS(中间系统到中间系统)</h4><p>一个分级的链路状态协议</p><p>分为两层：level-1，level-2。前者为普通区域，后者为骨干区域。</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv4问题</p><ul><li>网络地址短缺</li><li>地址分配不合理</li><li>路由速度慢–路由表大，IPv4头部字段13个，IPv6只有8个</li><li>缺乏安全功能，IPv6集成IPsec功能</li><li>不支持新业务模式</li></ul><p>IPv6采用固定首部：40Byte</p><p>​IPv6无头部校验和</p><ul><li>版本(4)</li><li>通信类型&#x2F;流量等级(8)—类似于IPv4的服务类型</li><li>流标签(20)</li><li>负载长度(16)–表示扩展报头长度</li><li>下一头部(8)–指明下一个头部类型</li><li>路数限制(8)–类似TTL</li><li>源IP(128)</li><li>目的IP(128)</li></ul><p>采用冒号分割的16进制数(8组)</p><p>一个或多个全0字段可以用一对冒号代替，双冒号只能出现1次。</p><p>地址分类</p><ul><li><p>单播地址</p><p>可聚合全球单播地址–前缀0<strong>01</strong></p><p>链路本地地址–结合Mac地址自动生成，前缀1111 1110 <strong>10</strong></p><p>站点本地地址–相当于IPv4的私网地址，前缀1111 1110 <strong>11</strong></p><p>记忆方法–一聚二恋三占</p></li><li><p>组播地址</p><p>IPv6无广播地址，前缀为1111 1111–FF00</p></li><li><p>信息播地址</p><p>表示一组接口的标识符，通常是路由距离最近的接口</p></li></ul><p>IPv6路由协议</p><p>​DHCP v6分为无状态配置和有状态配置</p><p>IPv4–IPv6过渡技术</p><ul><li>双协议栈—主机或路由器装有双协议</li><li>隧道技术–IPv6数据报变成IPv4数据报的数据部分</li><li>翻译技术–纯IPv4与IPv6节点之间进行通信</li></ul><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p>虚拟专用网(VPN)</p><p>​建立在公网上，由某一组织或某一群用户专用的通信网络</p><p>​二层：L2TP和PPTP(基于PPP)</p><p>​三层：<strong>IPsec</strong>和GRE</p><p>​四层：SSL&#x2F;TLS</p><p>实现虚拟专用网关键技术</p><ul><li>隧道技术</li><li>加密技术</li><li>密钥管理技术</li><li>身份认证技术</li></ul><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT主要解决IP地址短缺问题，子网内都使用私有地址，需要访问互联网时，通过路由器的全球IP地址向目标主机发起访问。</p><p>当对方回应后，装有NAT软件的路由器就通过内部维护的NAT地址转换表来找到到底这个数据报是发给本网络的哪一个主机的。</p><h1 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h1><p>运输层向它上面的应用层提供通信服务。只有主机的协议栈才有运输层，而路由器在转发分组的时候只用到了下三层。</p><p>网络层的传输的单位是主机，传输层的单位是进程。</p><p>复用和分用：应用层的应用进程都可以通过运输层再传送到网络层。运输层在收到网络层的数据后也能分别交付给指明的用户进程。</p><p>TCP&#x2F;IP体系中运输层的数据单元：TCP报文段&#x2F;UDP用户数据报</p><p>采用协议端口号(端口)来标识计算机中的应用进程，注意端口号只具有本地意义，它只是为了标志本计算机应用层中各个进程在和传输层交互时的层间接口。在互联网中，不同计算机中相同的端口号是没有关联的。TCP&#x2F;IP的运输层端口号占16bit。</p><p>So，两个计算机之间，要知道对方IP地址和端口号。这样才能和对应的应用进程通信。</p><p>我们时常和一些服务器打交道，所以这些服务器被固定分配端口号，以此才能和它们通信。这一类端口号数值为0<del>1023。我们客户端使用的端口号数值为49152</del>65535，当服务器接收到我们用户进程的报文时，就知道了客户端的端口。</p><h2 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h2><p>特点：无连接，尽最大努力交付，面向报文，无拥塞控制，开销小。</p><p>报文格式(8Byte)</p><ul><li>源端口(16)</li><li>目的端口(16)</li><li>长度(16)</li><li>校验码(16)</li></ul><h2 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h2><p>特点：面向连接，提供可靠传输服务，全双工通信，面向字节流，提供流量控制和窗口机制，每一条TCP连接只能有两个端点。</p><p>端点：套接字Socket&#x3D;(IP地址：端口号)</p><p>TCP固定部分报文(20Byte)</p><ul><li>源端口(16)</li><li>目的端口(16)</li><li>序号(32)—-TCP连接传送的字节流中每一个字节都按顺序编号</li><li>确认号ack(32)–当ACK为1时才有意义。期待收到对方下一个报文段的第一个数据字节的序号，例如发送方发了一个报文段，序号字段值是501，数据长度为200。则接收方收到后确认的时候确认号的值为701。</li><li>数据偏移(4)—指出TCP报文段的首部长度，单位1代表4Byte，默认20Byte。所以数据偏移最大值为15，即代表4*15&#x3D;60Byte，这就是TCP首部最大的长度(选项字段不能超过40Byte)</li><li>保留(6)</li><li>URG–当URG为1时，代表紧急指针字段有效，代表此报文段有紧急数据，尽快传送。</li><li>ACK–当ACK为1时，确认号ack才有用，连接建立后所有传送的报文都必须把ACK置1</li><li>PSH–一般接收方会有一个接收缓存，只有当缓存满了才会将数据向上推送给应用进程，当有报文段PSH&#x3D;1时，直接向上推送。</li><li>RST–当RST为1时，表示目前连接出现严重差错，必须释放连接后重新建立。</li><li>SYN–在连接建立时用来同步序号：当SYN&#x3D;1，ACK&#x3D;0时，表示这是一个连接请求报文段；若对方同意建立连接，则在响应的报文段中使SYN&#x3D;1，ACK&#x3D;1。</li><li>FIN—当FIN&#x3D;1，表示释放连接</li><li>窗口(16)–指的是发送本报文段的一方的接收窗口，表示我能够接收对方的多少数据–以字节为单位</li><li>校验和(16)—检验范围包括首部和数据部分</li><li>紧急指针(16)–当URG为1才有意义，指出本报文段的紧急数据的字节数</li></ul><h3 id="实现可靠传输"><a href="#实现可靠传输" class="headerlink" title="实现可靠传输"></a>实现可靠传输</h3><p>流量控制—停等协议</p><p>​原理：发送端发一帧，接收方收到一帧也回送一个应答信号(ACK)，发送端收到应答后再发下一帧。</p><p>流量控制—滑动窗口协议</p><p>​原理：允许连续发送多个帧而无序等待。 </p><p>连续ARQ协议</p><p>​停等流量控制技术余自动请求重发技术的结合</p><p>​发出一帧要等待应答信号ACK，收到否定应答NACK后重发，超时也重发。</p><p>​<strong>选择重发ARQ协议</strong>：重传某一帧，否定应答中携带要重发哪一帧信息。W发&#x3D;W收&lt;&#x3D;2^k-1^。k为帧编号位数</p><p>​<strong>后退N帧ARQ协议</strong>：发送方连续发送多个帧，若收到否定重传，假设收到NACK2，则代表需要重传2-已发送出的帧的最大序号。W发&#x3D;W收&lt;&#x3D;2^k^-1。k为帧编号位数</p><p>发送方维持一个发送窗口，位于发送窗口的分组都可以发送出去，发送完后窗口移动。接收方采用累计确认方法–对按序到达的最后一个分组发送确认，表示到此分组位置的数据都已正确接收。</p><p>当发送方发了前5个分组，中间3个分组丢失，此时接收方只能对前2个分组进行确认，而发送方就只能将后面三个分组再次重传—Go-back-N(回退N)</p><p>拥塞控制</p><p>TCP慢开始和拥塞避免算法</p><h3 id="TCP连接建立–三次握手"><a href="#TCP连接建立–三次握手" class="headerlink" title="TCP连接建立–三次握手"></a>TCP连接建立–三次握手</h3><ul><li>客户端SYN&#x3D;1，Seq&#x3D;x</li><li>服务器：SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ack&#x3D;x+1</li><li>客户端：ACK&#x3D;1，seq&#x3D;x+1，ack&#x3D;y+1</li></ul><h3 id="TCP连接释放–四次挥手"><a href="#TCP连接释放–四次挥手" class="headerlink" title="TCP连接释放–四次挥手"></a>TCP连接释放–四次挥手</h3><ul><li>客户端：FIN&#x3D;1，seq&#x3D;u</li><li>服务器：ACK&#x3D;1，seq&#x3D;v，ack&#x3D;u+1</li><li>服务器：FIN&#x3D;1，ACK&#x3D;1，seq&#x3D;w，ack&#x3D;u+1</li><li>客户端：ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1</li></ul><h1 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h1><p>解决某一类应用问题，该层许多协议都是基于C&#x2F;S方式，即便是P2P对等通信方式，实质上也是一种特殊的C&#x2F;S。注意C和S都是应用进程。</p><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>DNS、DHCP服务器必须为静态Ip地址</p><p>linux提供DNS服务组件为bind，主配置文件为named.conf</p><p>查看DNS服务器IP和诊断DNS基础结构的信息–nslookup</p><p>DNS配置文件(linux)</p><ul><li>&#x2F;etc&#x2F;resolv.conf</li><li>&#x2F;etc&#x2F;named.conf</li><li>&#x2F;etc&#x2F;hosts</li><li>host.conf</li></ul><p>用于将域名解析为IP地址，DNS被设计为一个联机分布式数据库系统。</p><p>当用户需要解析服务时，该应用进程就调用解析程序，封装DNS请求报文，以UDP数据报的方式发送给本地域名服务器，若本地域名服务器可以回答时，封装回答报文后返回；若不能，则此域名服务器就展示曾为DNS中的另一个客户，向其他域名服务器发出查询请求。</p><p>域名结构</p><p>N级域名.N-1级域名….二级域名.顶级域名</p><p>每个域名不超过63个字符，不区分大小写，除“-”之外不能使用其他标点符号。整个域名不能超过255个字符。</p><p>本地域名服务器—ISP、大学都可以拥有一个本地域名服务器。</p><p>为了提高域名服务器的可靠性，DNS域名服务器可以将数据冗余到多个域名服务器上，其中一个是主域名服务器，其他的是辅助域名服务器。</p><p>域名解析过程</p><ul><li>主机–本地域名服务器(递归查询)</li><li>本地域名服务器—根域名服务器(迭代查询)</li><li>本地域名服务器—顶级域名服务器</li><li>本地域名域名服务器—权限域名服务器</li><li>本地域名服务器—主机</li></ul><p>为了提高DNS查询效率，域名服务器中广泛地使用了高速缓存来保存最近查询过的域名以及从何处获得域名映射信息的记录。</p><p>DNS记录类型</p><ul><li>SOA：起始授权机构记录，表示在NS记录中哪一台是主机</li><li>A：主机名解析为IP地址</li><li>指针PTR：反向查询，IP–主机名</li><li>名字服务器NS：为一个域指定授权域名服务器</li><li>邮件服务器MX：指明区域的邮件服务器及优先级</li><li>别名CNAME：指定主机名的别名</li></ul><h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><p>基于TCP可靠的运输服务，采用C&#x2F;S方式。FTP服务器进程由两大部分组成：一个主进程，负责接收新的请求，另有若干从属进程，负责处理单个请求。</p><p>因为采用TCP可靠传输，采用两个进程分别实现控制和数据传送，端口号分别为21、20。</p><h2 id="简单文件传送协议TFTP"><a href="#简单文件传送协议TFTP" class="headerlink" title="简单文件传送协议TFTP"></a>简单文件传送协议TFTP</h2><p>基于UDP协议。</p><h2 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h2><p>基于TCP</p><h2 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h2><p>WWW服务是由分布在Internet中成千上万个超文本文档链接成的网络信息系统，大规模的、联机式的信息储藏所。</p><p>运行方式是C&#x2F;S，一般浏览器和网页所在的服务器建立TCP连接。建立连接后用HTTP和用户进行交互。HTTP定义了浏览器(客户端进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。URL(统一资源定位器)是浏览器对信息进行寻址的工具。HTML是制作网页的语言。</p><p>简单邮件传送协议SMTP</p><p>邮件读取协议POP3、IMAP</p><h2 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h2><p>客户端–DHCP discover(广播)  找到当前网络DHCP服务器</p><p>服务器–DHCP offer(单播)  携带分配给用户的IP地址</p><p>客户端  DHCP  Request(广播)  告知服务器自己将使用该IP地址</p><p>服务器  DHCP ACK(单播)  最终确认</p><p>PS：思科的全是广播，华为的就是上面情况</p><p>当客户机租约期到50%就会向DHCP服务器发送**DHCP Request(单播)**更新，服务器发送DHCP ACK(单播)给客户机。若服务器未发送，则87.5%时客户机再次发送DHCP Request更新。若服务器还未响应，则100%时客户机重新向服务器发送DHCP discover。</p><p>DHCP报文还包括可选部分Option</p><ul><li>option82</li><li>option43：为AP分配IP时，通告AC的地址</li></ul><h1 id="七、广域通信网"><a href="#七、广域通信网" class="headerlink" title="七、广域通信网"></a>七、广域通信网</h1><p>公共交换电话网PSTN：既可以语音通信也可以数据通信</p><p>​组成：本地回路，干线，交换机</p><p>​本地回路采用模拟线路，干线和交换机一般采用数字传输和交换技术</p><p>​本地回路</p><p>​DTE(数据终端设备)：PC&#x2F;电话机</p><p>​DCE(数据电路设备)：猫&#x2F;调制解调器&#x2F;modem(三个都是同一个东西)</p><p>DCE、DTE之间连接器的机械特性</p><p>​RS-232-C建议使用25针D型连接器，RS-232-C串行接口上大多适用9针连接器。</p><p>电气特性</p><p>​RS-232-C采用V.28标准电路</p><p>​速率20kb&#x2F;s，最长15m</p><p>3G语音为主，数据通信为辅。4G数据通信为主。</p><h1 id="八、移动通信与5G技术"><a href="#八、移动通信与5G技术" class="headerlink" title="八、移动通信与5G技术"></a>八、移动通信与5G技术</h1><p>移动通信方式：中国移动-3G-TD(时分复用)-SCDMA(码分多址)</p><p>5G技术包括</p><ul><li>超密集异构无线网络</li><li>大规模输入输出(MIMO)</li><li>毫米波通信</li><li>软件定义网络</li><li>网络功能虚拟化</li></ul><p>5G应用场景</p><ul><li>增强型移动互联网(20Gbps)—eMBB</li><li>海量连接物联网—mMTC</li><li>超低时延高可靠通信—uRLLC</li></ul><p>WLAN通信技术</p><p>​红外线、扩展频谱和窄带微波技术</p><p>扩展频谱通信：将信号散步到更宽的带宽上以减少发送阻塞和干扰</p><p>WLAN主要使用扩展频谱技术：</p><p>WLAN网络可分为基础无线网络、ADHoc网络和分布式无线系统</p><p>ISM频谱主要给工业、科学、医学机构使用</p><p>不重叠信道：13个信道，3个不重叠信道(1、6、11),中心频率间隔为5MHz</p><p>5G+5.8G频段：开放的不重叠信道有5个</p><p>802.11技术标准对比</p><ul><li>802.11–wifi</li><li>802.11b、802.11a–wifi2</li><li>802.11g-wifi3</li><li>802.11n–wifi4</li><li>802.11ac–wifi5</li><li>802.11ax—wifi6(第六代wifi技术)</li></ul><p>2.4GHz:802.11、802.11b、802.11g</p><p>5GHz：802.11a、802.11ac</p><p>2.4GHz+5GHz：802.11n、802.11ax</p><p>802.11定义的MAC层</p><p>802.11访问控制机制</p><ul><li>CSMA&#x2F;CD分布式协调功能：大家争用访问(有竞争)</li><li>PTS&#x2F;CTS信道预约(无竞争)</li><li>节点协议功能PCF：由AP集中轮询(无竞争)</li></ul><p>为什么无线不用CSMA&#x2F;CD：隐藏节点和暴露节点</p><p>802.11三种帧间间隔</p><ul><li>IFS(分布式协调IFS)：优先级最低，用于异步帧竞争访问</li><li>PIFS(点协调IFS)：优先级居中，在PCF操作中使用</li><li>SIFS(短IFS)：优先级高，用于需要立即响应的操作</li></ul><p>移动AD HOC网络</p><p>由无线移动节点组成的对等网，每个节点既是主机又是路由器，是一种MANNET(mobile Ad Hoc Network 无线即时网)网络。</p><p>MANNET网络特点</p><ul><li>不能使用传统路由协议，网络拓扑结构是动态变化的。</li><li>信号衰弱和噪声干扰影响很大</li><li>容易招致网络窃听，拒绝服务等攻击。</li></ul><p>WLAN安全机制</p><ul><li>SSID访问控制–隐藏SSID</li><li>物理地址过滤–黑白名单</li><li>WEP认证和加密–PSK预共享密钥</li><li>WAP(802.11i草案)–支持完整性认证和防重放攻击</li><li>WPA2(802.11i)–基于AES的CCMP</li></ul><h1 id="九、网络安全"><a href="#九、网络安全" class="headerlink" title="九、网络安全"></a>九、网络安全</h1><p>网络安全威胁类型</p><ul><li>窃听–搭线窃听，安装通信监控器读取网上信息</li><li>假冒–一个实体假扮成为另一个实体</li><li>重放–重复发送一份报文或报文的一部分。以便产生一个被授权效果(解决：时间戳，随机数)</li><li>流量分析</li><li>数据完整性破坏</li><li>拒绝服务DOS–SYN flooding攻击</li><li>资源的非授权使用</li><li>影门和特洛伊木马</li><li>病毒</li><li>诽谤</li></ul><p>网络攻击分类</p><ul><li>被动攻击–嗅探，监听，流量分析和会话拦截。难检测，防御手段是加密</li><li>主动攻击–假冒，重放，欺骗。重点是检测，防御手段有防火墙</li></ul><p>安全技术</p><ul><li>数据加密</li><li>数字签名</li><li>身份认证</li><li>防火墙</li><li>入侵检测</li><li>内容检查</li></ul><p>现代加密技术</p><p>私钥密码&#x2F;对称密码机制</p><ul><li>加密和解密使用相同的密钥，消息手法双方必须事先通过安全通道交换密钥。</li><li>优点：加密速度快，密文紧凑(不会增加太多因加密而产生的数据),使用长密钥难破解</li><li>缺：密钥分配问题，密钥管理问题，无法认证</li><li>DES，3DES，IDEA，AES，RC4&#x2F;5</li></ul><p>公钥密码&#x2F;非对称密码机制</p><ul><li>公钥加密，私钥解密可实现保密通信</li><li>私钥签名，公钥验证可实现数字签名</li><li>优点：分发方便，密钥管理少，支持数字签名</li><li>缺点：加密速度慢，数据膨胀高</li><li>RSA(512&#x2F;1024位密钥)，DH，Elgamal</li></ul><p>Hash算法</p><ul><li><p>也称杂凑函数，散列函数。能够将任意长的信息转换成固定长度的hash值(数字摘要)</p></li><li><p>特点：不可逆转，无碰撞性，雪崩效果(数据改变一点，Hash值变化特别大)</p></li><li><p>SHA(512–160)，MD5(512位数据块，产生128位摘要)，SM3(国产)(512–256)</p></li><li><p>应用：文件完整性校验，账号密码存储(彩虹表攻击)，用户身份认证</p></li></ul><p>混合密码</p><ul><li>用对称密钥加密明文，用非对称密钥加密堆对称密钥–&gt;一起发送—&gt;分开解密</li></ul><p>密码按用途分类</p><ul><li>核心密码、普通密码–用于保护国家秘密信息</li><li>商用密码：公民、法人可用</li></ul><p>数字签名</p><ul><li><p>签名方用主机私钥进行签名，对方收到后，用签名方的公钥进行验证。</p></li><li><p>RSA算法：用于确认发送者身份和消息完整性</p></li><li><p>特点</p><p>可信</p><p>不可伪造</p><p>不可重用</p><p>不能改变</p><p> 不能抵赖</p><p>接收者能核实发送者身份</p></li></ul><p>虚拟专用网(VPN)</p><p>​建立在公网上，由某一组织或某一群用户专用的通信网络</p><p>​二层：L2TP和PPTP(都基于PPP)</p><p>​三层：<strong>IPsec</strong>和GRE</p><p>​四层：SSL&#x2F;TLS</p><hr><p>​实现总分机构互联，常用IPsec。</p><p>​出差拨号访问内网，常用SSL、TLS</p><p>二层隧道技术</p><ul><li>PPTP只支持TCP&#x2F;IP体系</li><li>PPP协议(链路层协议)包括链路控制协议LCP和网络控制协议NCP</li><li>PPTP协议可以在点对点链路上传输多种上层协议的数据包，有校验位</li></ul><p>PPP认证方式</p><ul><li>PAP：两次握手验证协议</li><li>CHAP：三次握手–质询、回应、通过或拒绝</li></ul><p>IPsec用于增强IP网络的安全性</p><p>​一组协议</p><ul><li>认证头(AH):提供数据完整性和数据源认证，但不提供数据保密服务。MD5、SHA</li><li>封装安全负荷(ESP):提供苏剧加密功能，DES、3DES、AES</li><li>Internet密钥交换协议(IKE)：用于生成和分发在ESP和AH中使用的密钥</li></ul><p>两种封装模式</p><ul><li>传输模式</li><li>隧道模式(加了新的IP头部)</li></ul><p>SSL传输层安全协议</p><p>​TLS(传输层安全标准，基于SSL3.0)</p><p>​HTTPS&#x3D;HTTP+SSL&#x2F;TLS</p><p>​SSL包含记录协议，警告协议和握手协议</p><p>​HTTPS协议栈架构</p><p>​HTTP</p><p>​SSL&#x2F;TLS</p><p>​TCP</p><p>​IP</p><p>PGP</p><p>​电子邮件安全软件包，提供数据完整和数字签名服务</p><p>​采用RSA公钥证书进行身份验证，使用IDEA进行数据加密。使用MD5进行数据完整性验证。</p><p>​Kerberos用于进行身份认证的安全协议，支持AAA(认证、授权、审计)</p><p>S&#x2F;MINE</p><p>​提供电子邮件安全服务</p><p>SET</p><p>​保障电子商务安全</p><p>防火墙入侵检测</p><p>​防火墙实现内部网络信任网络与外部不可信任网络之间或是内部网络不同区域隔离与访问控制。</p><p>​技术分类</p><ul><li>包过滤防火墙(基于TCP、IP报头过滤)</li><li>状态化防火墙</li><li>应用层网关</li><li>应用层检测DPI</li></ul><p>​防火墙区域划分</p><ul><li><p>本地区域(local)</p></li><li><p>信任区域(Trust)</p></li><li><p>非信任区域(Untrust)</p></li><li><p>军事缓冲区域</p><p>PS：防火墙支持网络地址转换</p></li></ul><p>入侵检测系统IDS</p><p>​防火墙之后的第二道安全屏障</p><ul><li><p>入侵检测分类</p><p>按信息来源分类：HIDS(主机)、NIDS(网络)、DIDS(分布式)</p><p>按数据分析技术和处理方式</p><p>​异常检测：定义报警阈值</p><p>​误用检测：形成入侵模式库</p><p>​混合检测</p></li></ul><p>入侵防御系统IPS</p><p>​检测攻击并响应</p><p>IPS vs IDS</p><p>IPS串行部署，IDS旁路部署</p><p>IPS能检测入侵并主动防御，IDS只能发出警告</p><p>病毒名称构成：前缀(种类).名字.后缀(变种)</p><h1 id="十、网络操作系统和应用服务器"><a href="#十、网络操作系统和应用服务器" class="headerlink" title="十、网络操作系统和应用服务器"></a>十、网络操作系统和应用服务器</h1><p>用户组：相同性质用户归结在一起，统一授权。</p><p>本地用户信息存储在本地SAM数据库</p><p>常见用户组与权限</p><ul><li>Administrators 完全控制</li><li>Backup operators 可备份还原服务器文件</li><li>users 常见任务</li><li>power user 创建用户和组权力</li><li>Guests 拥有临时配置文件</li><li>everyone 权限最低</li></ul><p>计算机逻辑组织的模式</p><ul><li>工作组模式：每台计算机都拥有本地安全账户管理数据库SAM</li><li>域模式：用户信息存在域控制器，可以在域中漫游。</li></ul><p>活动目录(AD)：一个动态的分布式文件系统。对域中账户和资源对象存放并集中管理。</p><p>域控制器(DC): 域中安装了活动目录的计算机</p><p>AD存储的用户信息分散在多个DC。操作系统对信息进行备份和选择性复制，维护信息的一致性。</p><p>安装AD必须安装DNS组件，必须安装NTFS分区</p><p>活动目录工作组分类</p><ul><li>全局组</li><li>域本地组</li><li>通用组</li></ul><p>组策略</p><p>A：用户账号，G：全局组，U:通用组，DL：域本地组,R:表示资源权限</p><p>远程桌面</p><p>​远程桌面协议RDR，基于TCP 3389，win+r命令快捷键mstsc</p><p>samba服务</p><p>​文件和打印机共享服务</p><p>IIS服务器–因特网信息服务器</p><p>​可提供：web服务器，FTP服务器，SMTP服务器</p><p>linux Apache服务器配置</p><p>​web配置文件：httpd.conf。默认根目录：&#x2F;var&#x2F;www&#x2F;html或&#x2F;home&#x2F;httpd</p><p>​虚拟主机服务：是指一台物理设备提供多个Web服务，用Apache设置虚拟主机服务通常采用两种技术：基于IP地址、基于端口、基于名字。</p><p>Linux网络配置</p><ul><li>linux设备、配置都是文件</li><li>网络相关配置文件可以在系统运行时修改，不用重启或关闭守护程序。立即生效</li><li>&#x2F;etc&#x2F;hosts包含IP和主机名之间的映射，还包含主机别名</li><li>&#x2F;etc&#x2F;resolv.conf指定客户机域名搜索顺序和DNS服务器地址</li><li>netstat</li></ul><p>​-r 显示内核路由器</p><p>​-n 以数字格式显示远程和本地地址</p><ul><li><p>iptables(防火墙)</p><p>四表：raw，managle，nat，filter(确定死否放行该数据包(过滤))</p><p>五链(规则链)：input(处理入栈数据包)，putput，forward，prerouting，postrouting</p><p>命令：iptables -t 表名 管理选项 链名 条件匹配 -j 执行命令</p><p>​执行命令：drop(直接丢弃)，Reject(拒绝，回显ICMP不可达消息)</p><p>​条件匹配：-s  IP地址</p><p>​-d IP地址</p><p>​-sport 源端口</p><p>​-dport  目的端口</p><p>​-p  协议</p><p>​-P  策略</p></li></ul><p>linux文件管理</p><ul><li><p>根目录用“&#x2F;”表示</p></li><li><p>linux文件挂载–将一个文件系统的顶层目录挂到零一文件系统的子目录上。挂载点必须是目录。</p></li><li><p>挂在一个已知的目录节点上，这个节点可不为空。挂载后以前内容不可用。</p></li><li><p>less 按页显示，允许向前和向后翻阅。</p></li><li><p>linux根用户root，UID&#x3D;0</p></li><li><p>密码信息</p><p>&#x2F;etc&#x2F;passwd  对所有用户可读</p><p>&#x2F;etc&#x2F;shadow  root用户可读</p></li></ul><h1 id="十一、组网技术"><a href="#十一、组网技术" class="headerlink" title="十一、组网技术"></a>十一、组网技术</h1><p>交换机都用硬件实现</p><p>交换机分类–根据交换方式分</p><ul><li><p>存储转发式交换</p><p>优：可提供差错校验和非对称交换。</p><p>缺：延迟大</p></li><li><p>直通式交换</p><p>优：延迟小，交换速度快</p><p>缺：无检错能力，不能实现非对称交换</p></li><li><p>碎片过滤交换</p><p>开始转发前先检查帧是否大于64Byte。是则转发，不是则为冲突碎片，丢弃</p></li></ul><p>交换机分类–根据配置方式</p><ul><li>堆叠–扩展端口，避免单点故障</li><li>非堆叠</li></ul><p>交换机分类–层次结构划分</p><ul><li>核心~</li><li>汇聚~</li><li>接入~</li></ul><p>交换机性能评估标准</p><ul><li>交换容量：端口数 * 端口速率 * 2</li><li>VLAN表项(一般4094个)</li><li>传输模式：全双工，半双工</li></ul><h1 id="十二、网络管理"><a href="#十二、网络管理" class="headerlink" title="十二、网络管理"></a>十二、网络管理</h1><p>网络管理功能域</p><ul><li>故障管理–尽快发现故障，找出原因。采取补救措施</li><li>配置管理</li><li>计费管理</li><li>性能管理</li><li>安全管理</li></ul><p>代理与监视器的两种通信方式：轮询和事件报告</p><hr><p>SNMP简单网络管理协议</p><p>–应用层协议，通过UDP承载。网络管理不会增加网络负担</p><ul><li>ISO制订：CMIS&#x2F;CMIP  公共管理&#x2F;信息服务规范</li><li>基于TCP&#x2F;IP：SNMPv1，SNMPv2，SNMPv3</li><li>IEEE制订：基于物理层和数据链路层CMUL</li></ul><p>SNMP–两个服务三个端口五个报文</p><p>两个服务：SNMP service(客户机)，SNMP trap(网管，服务器)</p><p>三个端口：SNMP service：161，161；SNMP trap 162</p><p>五个报文：get-request，get-next-request，set-request–&gt;网关服务器找客户端</p><p>​get-response，trap–&gt;客户端反馈</p><p>SNMPv1机制与问题</p><p>​管理站与代理之间可以是一对多或多对一关系</p><p>​通过团体名Community验证实现–明文传输，不安全</p><p>SNMPv2</p><p>​增加：get bulk，inform</p><p>SNMPv3</p><p>​重新定义了网络管理模块和安全机制。将管理端和代理统称为SNMP实体(Entry)</p><p>​两种威胁未解决：拒绝服务和通信分析</p><p>​安全机制：认证和加密传输</p><ul><li>时间序列模块</li><li>认证模块</li><li>加密模块</li></ul><p>RMON</p><p>​用于监视网络通信情况，定义了管理信息库RMON MIB-11 流量信息与SNMP MIB(设备信息)</p><p>​目标：监视子网范围内通信</p><p>网络管理命令</p><ul><li><p>ipconfig</p><p>&#x2F;all  显示DHCP和MAC等详细信息</p><p>&#x2F;renew 重新获取IP</p><p>&#x2F;release 释放IP</p><p>&#x2F;displaydns 消除DNS缓存</p><p>&#x2F;flushdns 刷新DNS缓存</p></li><li><p>ping &#x2F; traceroute</p><p>ping 选项：-t 持续ping;-n number ping多少个包；-a ip解析为主机名</p><p>tracert&#x2F;traceroute：*代表NAT或防火墙</p></li><li><p>pathping &#x3D;&#x3D; ping+traceroute</p></li><li><p>arp</p><p>选项：-a 显示当前ARP缓存，-s 静态绑定ARP，-d 删除某ARP缓存</p></li><li><p>netstat</p><p>显示tcp连接，侦听端口及统计信息</p><p>-n  显示活动的tcp连接</p><p>-r &#x3D; route print  查兰本机路由表</p></li><li><p>route print</p><p>add 添加静态路由，重启不在</p><p>-p 与add连用，重启还在</p></li><li><p>nslookup</p><p>显示DNS查询信息，诊断，故障排查</p></li></ul><h1 id="十三、网络规划设计"><a href="#十三、网络规划设计" class="headerlink" title="十三、网络规划设计"></a>十三、网络规划设计</h1><p>综合布线六大子系统</p><ul><li>工作区子系统–终端设备到信息插座的整个区域</li><li>水平子系统–各个楼层接线间的配线架到工作区信息插座之间所安装的线缆</li><li>干线~ – 建筑物的主干线缆，实现各楼层设备间子系统的互联</li><li>设备间~  建筑物的进户线，交换设备，电话，计算机，适配器以及保安设备组成</li><li>管理~ – 楼层的接线间内，由各种交换设备组成</li><li>建筑群~   连接各个建筑物的通信系统</li></ul><img src="/2023/11/03/computer-network/Users\yongji\AppData\Roaming\Typora\typora-user-images\image-20230923165032654.png" alt="image-20230923165032654" style="zoom:33%;"><p>网络规划设计模型–五阶段模型(瀑布模型)</p><p>​需求分析–通信规范分析–逻辑网络设计(网络拓扑，IP地址规划，安全管理)–物理网络设计(综合布线，设备清单)–实施(用户培训)</p><p>网络安全措施</p><ul><li>网络安全：安全区域划分</li><li>系统安全：漏洞发现与补丁修复</li><li>应用安全：数据库安全，web服务安全</li></ul><p>技术评价</p><ul><li><p>通信带宽，技术成熟度，连接服务类型，可扩展性，高投资产出比</p><p>PS：对大型网络工程来说，项目本身不能成为新技术的试验田</p></li></ul><p>局域网三层架构</p><ul><li>互联网接入交换机：用户接入，安全控制</li><li>局域网汇聚交换机：策略和路由控制</li><li>局域网核心交换机：高性能，快速转发</li></ul><p>广域网接入技术</p><p>​HFC主干光纤，光纤到小区，钥缆接入</p><p>​PON无源光网络，上行是TDMA，下行是广播</p><h1 id="补充、计算机基础内容"><a href="#补充、计算机基础内容" class="headerlink" title="补充、计算机基础内容"></a>补充、计算机基础内容</h1><p>进制转换</p><p>掌握2、10、16进制的相互转换。包括小数</p><p>带宽与存储计算</p><p>​bit：网络数据传输的最小单位</p><p>​Byte：由8bit组成，存储空间最小单位</p><p>存储领域：1KB&#x3D;1024B</p><p>网络领域：1Kb&#x2F;s&#x3D;1000b&#x2F;s</p><p>计算机硬件系统由运算器，控制器，存储器，输入&#x2F;输入设备(I&#x2F;O)五大部件组成，运算器和控制器组成CPU</p><p>指令执行过程：取指，译码，执行</p><p>前两个过程由控制器完成：通常由程序计数器(PC)，指令寄存器(IR)，指令译码器，状态&#x2F;条件寄存器，时序发生器，微操作信号发生器组成。</p><ul><li>PC：存放下一条指令所在单元的地址</li><li>IR: 存放当前从主存读出的正在执行的一条指令</li><li>指令译码器:分析指令的操作码，以决定操作的性质和方法</li><li>微操作信号发生器：产生每条指令的操作信号，并将信号送往相应的部件进行处理</li></ul><p>运算器：负责完成算数，逻辑运算功能：通常由ALU(算数&#x2F;逻辑单元)，通用寄存器，状态寄存器，多路转化器构成。</p><p> 指令集RISC(精简指令集)与CISC(复杂指令集)</p><p>当下最广泛的AMD x86系列和IntelCPU都是CISC架构，指令系统复杂和庞大，指令数目一般大于200条，指令字长不固定，支持多种方式寻址。指令执行时间和使用频率相差较大。通用寄存器数量少。绝大多数为微程序控制方式。</p><p>计算机输入输出I&#x2F;O控制有三种方式：</p><ul><li>直接程序控制(软件方式)—耗费CPU资源</li><li>中断方式(软件+硬件方式)—出现中断，CPU暂停执行当前程序并保存断点及现场信息。根据中断类型从中断向量表中找到中断程序的入口地址。转而去执行这些事情，处理完后再执行原先程序。</li><li>直接存储器存取(DMA)–用专门硬件设备来控制内存与外设之间的数据交流，无需CPU介入</li></ul><p>操作系统五大功能</p><ul><li>进程管理</li><li>存储管理</li><li>文件管理</li><li>设备管理</li><li>作业管理</li></ul><p>国产操作系统：UOC，麒麟，中科方德，深度，红旗—都是基于Linux</p><p>移动操作系统：IOS，Android，鸿蒙—都是基于linux</p><p>进程是程序动态执行的过程，每个进程拥有独立的地址空间。同一个进程的线程共享进程资源。</p><p>进程是操作系统资源分配的基本单位，而线程是处理机调度和执行的基本单位</p><p>线程之间的切换开销小</p><p>多进程比多线程健壮</p><p>线程的程序计数器和栈不能被共享，进程的数据区，代码区，堆区可以被共享。</p><p>死锁：互相争夺资源，典型避免死锁的算法是银行家算法，不产生死锁的条件：资源数&gt;&#x3D;并发进程数*(每个进程所需资源-1)+1</p><p>文件存储空间管理—位示图</p><p>文件目录：windows以盘符为根，Linux只有一个根目录。</p><p>绝对路径：完整访问路径，相对路径：从当前路径出发的访问路径；相对路径访问更快</p><p>软件工程：以工程学思路进行软件开发</p><p>软件工程三要素：</p><ul><li>方法</li><li>工具</li><li>过程</li></ul><p>信息系统生命周期</p><ul><li>系统规划–可行性研究</li><li>系统分析–逻辑模型</li><li>系统设计–物理模型</li><li>系统实施–购置</li><li>系统运行和维护</li></ul><p>软件生命周期</p><ul><li>计划阶段–总体目标和范围</li><li>分析阶段—用户需求</li><li>设计阶段–体系结构</li><li>实现模型–编码</li><li>测试阶段</li><li>运行维护阶段</li></ul><p>软件开发模型</p><ul><li><p>瀑布模型</p><p>强调先后顺序</p><p>每一步完成都需要评审，通过则进入下一项，否则返回之前</p><p>需求明确或很少变更的项目，开发团队比较弱的情况。有厚实的行业实践基础，整批一次性交付有利于干系人。</p><p>开发模型是线性的，用户直到过程末期才能看到开发成果，从而增加开发风险。不适应用户需求的变化。</p></li><li><p>螺旋模型</p><p>强调风险</p><p>在瀑布模型和原型化模型的基础上演变而来，每一次迭代都包含四个步骤：制定计划，风险分析，实施工程，客户评估。</p><p>软件开发是一系列的增量发布</p><p>每一次迭代都有风险分析</p><p>适用于大规模团队开发项目</p></li><li><p>迭代模型</p><p>分为多个阶段</p><p>执行一次过程串就是一次迭代。多次交付</p><p>RUP软件过程就是迭代模型的一种。RUP中被分解为四个顺序阶段：初始阶段，细化阶段，构建阶段，交付阶段。每个阶段的工作都包含业务建模，需求获取，分析和设计，实现，测试，部署。只是每个阶段对这些工作的倾向有所改变</p></li><li><p>V模型</p><p>强调测试和开发同等重要</p><p>由左右两边组成，左边是用户需求，需求分析，概要设计，详细设计；右边是单元测试，集成测试，系统测试，验收测试。</p><p>适用于需求明确，需求变更不频繁的情况。</p><p>验收测试由用户或业务专家进行</p></li><li><p>原型化模型</p><p>强调以用户为核心</p><p>创建一个快速原型，通过与干系人充分讨论和分析，最终弄清需求。在原型基础上开发出令用户满意的产品。</p><ul><li>抛弃型原型</li><li>进化型原型</li></ul></li><li><p>敏捷开发模型</p><p>强调以人为中心</p><p>以人为核心，迭代，循序渐进的开发方法，强调开发团队与业务专家之间的紧密协作，面对面沟通(认为比书面的文档更有效)</p><p>能够很好适应需求变化</p><p>常见敏捷开发方法：极限编程(XP)，Scrum</p><p>适用于中小型开发</p></li></ul><p>软件开发方法</p><ul><li><p>结构化方法</p><p>由结构化分析，结构化设计，结构化程序设计组成</p><p>自顶向下，逐步求精和模块化设计</p><p>开发周期长，难以适应需求变化，很少考虑数据结构</p><p>适合于数据处理领域的问题，但不适应于规模较大，比较复杂的系统开发</p></li><li><p>面向对象方法</p><p>构建在类和对象之上，按照业务功能进行分组。</p><p>紧耦合</p><p>具有更好的复用性，有利于用户和开发人员沟通，缩短开发时间。</p><p>面向对象三大特征：封装，继承，多态</p></li><li><p>原型化方法</p><p>快速建立一个系统模型展示给用户，在此基础上与用户交流。</p><p>使系统的开发周期缩短，成本和风险降低。速度加快。用户参与程度大大提高。</p></li><li><p>面向服务方法</p><p>采用接口的形式暴露出来，进一步将接口的定义和实现进行解耦。</p><p>提高系统的可复用性，信息资源共享和系统之间的互操作性。</p><p>关注的是业务，以业务驱动技术</p><p>松耦合，更高重用度</p></li></ul><p>软件设计方法</p><ul><li><p>结构化设计SD</p><p>自顶向下，逐步求精和模块化的过程。</p><p>高内聚，低耦合</p></li><li><p>面向对象设计OOD</p></li></ul><p>开发语言</p><ul><li><p>标记语言</p></li><li><p>脚本语言</p><p>又称为动态语言，是一种编程语言。只有在调用时进行解释，可以定义函数和变量，跨平台移植难度低。Python，javaScript,PHP</p></li><li><p>编译型语言</p><p>程序在执行之前需要一个专门编译的过程，将程序编译为机器语言。程序执行效率高，依赖编译器。跨平台一直难度大。C，C++，java</p></li></ul><p>脚本语言和编译型语言主要区别</p><p>是否生成目标代码，编译型语言要生成类似于exe这种可执行文件</p><p>软件测试</p><p>​按照是否运行程序可分为</p><ul><li><p>静态测试</p><p>文档：检查单</p><p>代码：桌面检查，代码走查，代码审查</p></li><li><p>动态测试</p><p>白盒测试–结构测试，最常用的技术是逻辑覆盖</p><p>黑盒测试–功能测试</p></li></ul><p>测试类型</p><ul><li>单元测试–模块内的问题</li><li>集成测试–模块间的问题</li><li>确认测试–内部确认测试，Alpha测试(开发环境),Beta(实际使用环境测试)，验收测试。验证各项和用户需求是否一致</li><li>系统测试–真实环境下，软件+硬件</li><li>配置项测试</li><li>回归测试–测试软件变更后</li></ul><p>测试分类</p><ul><li><p>单元测试</p><p>模块，类，函数和对象等，或更小的单元。由白盒测试工程师或开发人员测试。依据代码，详细设计文档来进行测试。测试方法：白盒测试</p></li><li><p>集成测试</p><p>模块间接口。由白盒测试工程师或开发人员测试。依据单元测试文档，概要设计文档进行测试。测试方法：白盒测试+黑盒测试</p></li><li><p>系统测试</p><p>整个系统。由黑盒测试工程师测试。测试依据：需求规格说明书。测试方法：黑盒测试</p></li><li><p>验收测试</p><p>整个系统，由最终用户或需求方测试，测试依据：用户需求，验收标准。测试方法：黑盒测试</p></li></ul><p>标准化</p><p>国际标准：ISO，IEC，ITU</p><p>当相应的国家标准实施后，行业标准自行废止</p><p>JB&#x2F;T 为机械行业推荐性标准</p><p>地方标准以DB开头。地方标准不得与国家标准与行业标准相抵触。国家标准和行业标准公布实施后，相应的地方标准自行废止。</p><p>企业标准以Q开头</p><p>企业标准应在发布三十日内向政府备案</p><p>我国国家标准5年内要进行复审，即国家标准有效期为5年。</p><p>知识产权</p><p>我国在IT领域主要有《著作权法》，《计算机软件保护条例》，《专利法》，《商标法》和《反不当竞争法》</p><p>计算机软件参照《著作权法》</p><p>知识产权保护期限：注册商标，有效期为十年，可以续注。署名权没有限制</p><p>知识产权归属：由单位提供物质技术进行创作或有合同，除署名权外其他著作权归单位。属于本职工作或由单位支持，单位享有著作权。合同中未约定著作权归属，归属为创作方</p><p>对于个人作品而言，以下行为是不侵权的：</p><ul><li>个人学习，介绍或评论时引用</li><li>新闻报道引用</li><li>学校教学，研究及图书馆少量复制</li><li>将汉字作品翻译为少数名族文字</li><li>改为盲文出版</li><li>免费表演</li><li>执行公务</li></ul><h1 id="华为配置专题"><a href="#华为配置专题" class="headerlink" title="华为配置专题"></a>华为配置专题</h1><p>华为设备配置视图</p><p>用户视图&lt; Huawei &gt;:可以查看简答运行状态和统计信息</p><p>系统视图[Huawei]：在用户视图使用system-view可以进入，可以配置全局参数，进入其他视图</p><p>其他视图：</p><ul><li>用户接口视图[huawei-ui-vty0-4]：user-interface vty 0 4</li><li>接口视图[huawei-gigabitEthernet]：interface g&#x2F;0&#x2F;0&#x2F;0</li><li>ACL视图[huawei-acl-basic-2000]：acl 2000</li><li>VLAN视图[huawei-vlan-10]：vlan 10</li><li>路由协议视图[huawei-ospf-1]：ospf 1</li></ul><p>quit–返回当前视图，返回上级视图</p><p><strong>sysname</strong>  newname  设备命令</p><p>telnet server <strong>enable</strong> 开启设备telnet功能</p><p>protocol <strong>inbound</strong> telnet 通过telnet协议登陆</p><p>authentication-mode aaa 设置认证方式为aaa</p><p>批量创建–vlan batch 10 20</p><p>port link-type access 把交换机接口模式设置为access</p><p>port default vlan 100 把接口划入100</p><p>interface vlanif 100 进入三层vlanif接口</p><p>ip address  IP地址 掩码 —配置ip地址</p><p>dhcp enable 启用dhcp服务</p><p>ip pool 1  &#x2F;&#x2F;创建IP地址池1，只能在系统视图下</p><p>network ip地址 mask子网掩码&#x2F;&#x2F;配置地址池范围</p><p>dns-list IP地址 &#x2F;&#x2F;配置dns</p><p>gateway-list IP地址  &#x2F;&#x2F;配置PC电脑网关</p><p>excuded-ip-address  IP地址&#x2F;&#x2F;保留IP地址</p><p>lease 10&#x2F;&#x2F;配置租期</p><p>dhcp select global&#x2F;interface&#x2F;&#x2F;全局或接口dhcp服务器</p><p>time-range workday 8:30 to 18:00 working-day&#x2F;&#x2F;ACL访问控制列表配置时间段</p><p>rule permit source IP地址  time-range workday&#x2F;&#x2F;只允许这一个ip在工作日可以telnet交换机</p><p>rule deny&#x2F;&#x2F;拒绝其他用户</p><p>acl 2000 inbound&#x2F;&#x2F;应用ACL</p><p>nat address-group  1 ip地址1  ip地址2  &#x2F;&#x2F;配置NAT地址池1</p><p>nat outbound 2000 address-group 1 no-pat&#x2F;&#x2F;设置ACL2000匹配的源代码，转换为地址池1的地址，并且不开启端口NAT</p><h2 id="DHCP配置"><a href="#DHCP配置" class="headerlink" title="DHCP配置"></a>DHCP配置</h2><p><strong>基于全局地址池的DHCP配置</strong></p><p>开启dhcp功能：dhcp enable</p><p>配置全局地址池可动态分配的IP地址范围：network ip-address [mask]</p><p>配置dhcp客户端的网关地址：gateway-list ip-address</p><p>配置dhcp客户端使用的dns服务器的ip地址：dns-list ip-address</p><p>配置ip地址租期：lease time </p><p>使能接口的dhcp服务器功能：dhcp select global</p><p><strong>基于接口地址池的dhcp配置</strong></p><p>开启接口采用接口地址池的dhcp服务器端功能：dhcp select  interface</p><p>指定接口地址池下的DNS服务器地址：dhcp server dns-list ip-address</p><p>配置接口地址池中不参与自动分配的ip地址范围：dhcp server excluded-ip-address start-ip-address [end-ip-address]</p><p>配置dhcp服务器接口地址池中IP地址的租用有效期限：dhcp server lease time&#x2F;&#x2F;默认为1天</p><p>使能接口的dhcp服务器功能：dhcp select global</p><h2 id="ACL配置"><a href="#ACL配置" class="headerlink" title="ACL配置"></a>ACL配置</h2><p>技术背景：需要一个工具，实现流量控制。例如，某公司为保证财务数据安全，禁止某部门访问财务服务器，但总裁办不受限制。</p><p>ACL是由一系列permit和deny语句组成的、有序规则的列表。</p><p>ACL是一个匹配工具，能够对报文进行匹配和区分。</p><p>acl number 2000 访问控制列表的编号，写一条编号为2000的acl</p><p>rule 5 permit&#x2F;deny source 1.1.1.0     0.0.0.255</p><p>–  5代表规则编号(若缺少，自动在上一次的编号上加5），permit&#x2F;deny代表动作。</p><p>— 最后的部分为通配符，0.0.0.255–匹配规则：0表示匹配，1表示随机分配；1.1.1为严格匹配，后面的取值为0~255。特殊通配符，0.0.0.0可写为0，255.255.255.255可写为any</p><p>系统在ACL流量控制配置时默认在最后加上deny，路由配置加上permit</p><p>基本ACL：编号范围2000~2999，只能匹配源ip地址</p><p>高级ACL：编号范围3000~3999，可匹配源ip，目的ip，tcp源&#x2F;目的端口号，udp源&#x2F;目的端口号，协议号</p><p><strong>配置顺序</strong>(config模式)</p><p>系统按照ACL规则编号从小到大的顺序进行报文匹配</p><p><strong>ACL应用位置</strong></p><p>inbound(入站)方向，outbound(出站)方向</p><p><strong>ACL基础配置命令</strong></p><p>acl [number] acl-number   —创建基本ACL</p><p>基本ACL：rule [rule-id] deny&#x2F;permit source source-address any  time-range</p><p>interface GigabitEthernet 0&#x2F;0&#x2F;1  –进入接口0&#x2F;0&#x2F;1</p><p>​traffic-filter inbound acl 2000–在此接口配置入方向流量过滤(traffic-filter)</p><p>高级ACL：rule [rule-id] deny&#x2F;permit ip  [destination] | source</p><h2 id="NAT配置"><a href="#NAT配置" class="headerlink" title="NAT配置"></a>NAT配置</h2><p>NAT缓解IPv4地址短缺问题。提升内网安全性。IP分为公有和私有IP。</p><p>私有地址</p><ul><li>A：10</li><li>B:172.16~172.31</li><li>C:192.168</li></ul><p>出口设备部署NAT</p><p><strong>静态NAT</strong></p><p>每个私有地址都有一个与之对应并且固定的共有地址。一对一映射，支持双向互访</p><p>nat static enable</p><p>nat static global [globel-address] inside [host-address]</p><p><strong>动态NAT</strong></p><p>将可用的公网IP组成一个地址池</p><p><strong>nat address-group</strong> groupindex start-address end-address–创建公网地址池</p><p><strong>nat outbound</strong> acl-number address-group group-index no-pat–关联ACL与地址池进行动态地址转换，no-pat参数指定不进行端口转换</p><p><strong>NAPT</strong></p><p>在原本动态NAT上再加上端口，可以实现地址的进一步复用</p><p><em>nat outbound</em> acl-number address-group group-index </p><p><strong>Easy IP</strong></p><p>适用于不具备固定公网IP地址的场景，即没有公网IP地址池的情况，如通过DHCP，PPPoE拨号获取地址的私有网络出口。</p><p>acl 2000</p><p>rule 5 permit source 192.168.1.0 0.0.0.255</p><p>interface GigabitEthernet0&#x2F;0&#x2F;1</p><p><em>nat outbound</em> 2000</p><p><strong>NAT-server</strong></p><p>将内网服务器映射到公网，指定[公有地址:端口]与[私有地址:端口]的一对一映射。</p><p>保证内网服务器安全问题</p><p>负载均衡</p><p>nat server protocol tcp global 公网地址 端口 inside 私有地址 端口</p><h2 id="网关冗余技术VRRP"><a href="#网关冗余技术VRRP" class="headerlink" title="网关冗余技术VRRP"></a>网关冗余技术VRRP</h2><p>单网关危机—当网关Router出现故障时，本网段内以该设备为网关的主机都不能与Internet进行通信。</p><p>VRRP–通过把几台路由器设备联合组成一台虚拟机的“路由设备”，使用一定机制保证当前主机的下一跳路由设备出现故障时，及时将业务切换到备份路由设备。</p><p>VRRP路由器—运行VRRP的路由器。</p><p>VRID—一个VRRP组由多台协同工作的路由器的接口组成，使用相同的VRID(Virtual Router Identifier)进行标识。一个VRRP组只能出现一台Master路由器。</p><p>虚拟路由器—VRRP为每一组抽象出一台虚拟“路由器”，该路由器并非真实存在的物理设备，而是由VRRP虚拟出来的逻辑设备。</p><p>虚拟IP地址与虚拟MAC地址—虚拟路由器拥有自己的IP和MAC地址，IP地址由管理员在配置VRRP时指定，一台虚拟路由器可以有一个或多个IP地址，通常情况下用户使用该地址作为网关地址。而虚拟MAC地址的格式是“0000-5e00-01xx”,xx为VRID。</p><p>Master路由器–在VRRP group中承担报文转发任务，以一定的时间间隔周期性地发送VRRP报文，通知组内Backup路由器关于自己的存活情况。</p><p>backup路由器—备份路由器，backup路由器将会实时侦听Master路由器发送出来的VRRP报文，它随时准备接替Master路由器的工作。</p><p>priority—优先级值是选举Master和backup的依据，值越大越优先，优先级取值0~255.值相等比较接口IP大小，大者优先。</p><p><strong>VRRP应用</strong></p><ul><li>VRRP负载分担–流量转发负载均衡</li><li>VRRP与MSTP结合应用</li><li>VRRP监控上行端口–当Master感知上行端口或者链路发生故障，可主动降低VRRP优先级，从而让backup通过选举切换为Master，指导报文转发。</li><li>VRRP与BFD(毫秒级的状态检测)联动—Backup设备通过BFD感知故障发生之后，不再等待master_down_timer计时器超时而会在BFD检测周期结束后立即切换VRRP状态，此时<strong>可以实现毫秒级的主备切换</strong></li></ul><p>**VRRP基本配置 **</p><p><strong>vrrp vrid</strong>  vritual-router-id <strong>virtual-ip</strong> virtual-address–创建vrrp备份组并给备份组配置虚拟IP地址</p><p><strong>vrrp vrid</strong> virtual-router-id <strong>priority</strong> priority-value–配置路由器在备份组的优先级</p><p><strong>vrrp vrid</strong> virtual-router-id <strong>preempt-mode timer delay</strong> delay-value–配置备份组中设备的抢占延迟时间，当主设备恢复过来后的抢占延迟，与下面句配置非抢占模式有关联</p><p><strong>vrrp vrid</strong> virtual-router-id **preempt-mode disable**–配置VRRP备份组中设备采用非抢占式模式</p><p><strong>vrrp vrid</strong> virtual-router-id track <strong>interface</strong> interface-type interface-number [<strong>increased</strong> value-increased | <strong>reduced</strong> value-decreased]–配置当上行接口或链路出现故障时，增加或减少自身优先级</p><p><strong>vrrp vrid</strong> virtual-router-id <strong>track bfd-session</strong> {bfd-session | <strong>session-name</strong> bfd-configure-name} [<strong>increased</strong> value-increased | <strong>reduced</strong> value-reduced]–配置VRRP备份组联动普通BFD会话</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
